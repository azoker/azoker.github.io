{"meta":{"title":"断罪的眼泪","subtitle":"那时你心比天高，现在怎么沉默不语","description":"","author":"azoker","url":"https://azoker.top","root":"/"},"pages":[{"title":"关于","date":"2023-10-14T08:05:30.000Z","updated":"2024-08-23T06:36:39.253Z","comments":false,"path":"about/index.html","permalink":"https://azoker.top/about/index.html","excerpt":"","text":"📕个人学习编程所有的总结"},{"title":"categories","date":"2023-10-05T05:35:53.000Z","updated":"2024-08-21T06:23:54.594Z","comments":false,"path":"categories/index.html","permalink":"https://azoker.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Win10右键菜单添加在此处打开CMD命令窗口","slug":"一切为了开发/Win10右键菜单添加在此处打开CMD命令窗口","date":"2024-11-14T06:41:26.000Z","updated":"2024-11-14T07:40:48.789Z","comments":true,"path":"2024/11/14/一切为了开发/Win10右键菜单添加在此处打开CMD命令窗口/","link":"","permalink":"https://azoker.top/2024/11/14/%E4%B8%80%E5%88%87%E4%B8%BA%E4%BA%86%E5%BC%80%E5%8F%91/Win10%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%B7%BB%E5%8A%A0%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80CMD%E5%91%BD%E4%BB%A4%E7%AA%97%E5%8F%A3/","excerpt":"貌似Win10右键文件夹没有通过CMD打开的选项，本文简单解决。","text":"编写注册表123456789101112131415Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here]@=&quot;在此处打开命令行&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here\\command]@=&quot;\\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe\\&quot;&quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt]@=&quot;在此处打开命令行&quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt\\command]@=&quot;\\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe\\&quot; \\&quot;cd %1\\&quot;&quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here]@=&quot;在此处打开命令行&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here\\command]@=&quot;\\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe\\&quot;&quot; 另存为reg 注：如果你要使用中文请使用ANSI编码，否则可能是英文（使用了UTF-8）或者乱码（使用了不支持中文的编码） 大功告成","categories":[{"name":"一切为了开发","slug":"一切为了开发","permalink":"https://azoker.top/categories/%E4%B8%80%E5%88%87%E4%B8%BA%E4%BA%86%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://azoker.top/tags/Windows/"}]},{"title":"使用oshi遇到getIndex方法爆红问题解决","slug":"Java后端开发/使用oshi遇到getIndex方法爆红问题解决","date":"2024-11-08T01:56:33.000Z","updated":"2024-11-08T02:45:41.168Z","comments":true,"path":"2024/11/08/Java后端开发/使用oshi遇到getIndex方法爆红问题解决/","link":"","permalink":"https://azoker.top/2024/11/08/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8oshi%E9%81%87%E5%88%B0getIndex%E6%96%B9%E6%B3%95%E7%88%86%E7%BA%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"具体爆红原因是：找不到方法调用 TickType.NICE.getIndex() 的候选者","text":"前因后果 这是若依项目中的一段代码，它使用了oshi这个依赖，但是在编译器中爆红，并且提示：无法解析 ‘TickType’ 中的方法 ‘getIndex’，但是并不影响使用，猜想是编译器的问题，当然，若依的issue也给出了解决办法： 把getIndex方法更改为ordinal方法 将oshi的版本退回到6.4.8 笔者备注：ordinal是枚举类自带的方法，若依设置oshi版本的地方在项目根目录的pom.xml里面。","categories":[{"name":"Java后端开发","slug":"Java后端开发","permalink":"https://azoker.top/categories/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"oshi","slug":"oshi","permalink":"https://azoker.top/tags/oshi/"}]},{"title":"OpenCV本地库没有被正确加载","slug":"Java后端开发/OpenCV本地库没有被正确加载","date":"2024-11-04T01:40:08.000Z","updated":"2024-11-14T07:45:29.451Z","comments":true,"path":"2024/11/04/Java后端开发/OpenCV本地库没有被正确加载/","link":"","permalink":"https://azoker.top/2024/11/04/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/OpenCV%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%B2%A1%E6%9C%89%E8%A2%AB%E6%AD%A3%E7%A1%AE%E5%8A%A0%E8%BD%BD/","excerpt":"加载OpenCV核心出现问题，需要手动加载一下。","text":"报错如下Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: org.opencv.core.Mat.n_Mat(III)J 解决办法直接静态执行加载方法： 123static &#123; System.loadLibrary(Core.NATIVE_LIBRARY_NAME);&#125;","categories":[{"name":"Java后端开发","slug":"Java后端开发","permalink":"https://azoker.top/categories/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://azoker.top/tags/OpenCV/"}]},{"title":"使用OpenCV报错找不到某某dll文件","slug":"Java后端开发/使用OpenCV报错找不到某某dll文件","date":"2024-10-30T06:32:26.000Z","updated":"2024-10-30T06:54:05.824Z","comments":true,"path":"2024/10/30/Java后端开发/使用OpenCV报错找不到某某dll文件/","link":"","permalink":"https://azoker.top/2024/10/30/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8OpenCV%E6%8A%A5%E9%94%99%E6%89%BE%E4%B8%8D%E5%88%B0%E6%9F%90%E6%9F%90dll%E6%96%87%E4%BB%B6/","excerpt":"报错：no opencv_java455 in java.library.path","text":"报错如下no opencv_java455 in java.library.path 解决办法先去OpenCV官网下载OpenCV安装包，然后自行安装到一个找得到的位置，安装完成之后，找到下面的文件： 然后复制粘贴到JDK的bin目录即可。","categories":[{"name":"Java后端开发","slug":"Java后端开发","permalink":"https://azoker.top/categories/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://azoker.top/tags/OpenCV/"}]},{"title":"TomCat上传文件超过大小限制","slug":"Java后端开发/TomCat上传文件超过大小限制","date":"2024-10-30T03:21:51.000Z","updated":"2024-10-30T03:36:41.311Z","comments":true,"path":"2024/10/30/Java后端开发/TomCat上传文件超过大小限制/","link":"","permalink":"https://azoker.top/2024/10/30/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/TomCat%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%B6%85%E8%BF%87%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/","excerpt":"报错：The field file exceeds its maximum permitted size of 1048576 bytes","text":"报错如下The field file exceeds its maximum permitted size of 1048576 bytes 解决办法12345spring: servlet: multipart: max-request-size: 50MB # 单次请求文件最大 max-file-size: 50MB # 单个文件最大 思考不难看出，TomCat上传文件最大的大小是1MB，肯定不符合实际，所以基本都要设置。","categories":[{"name":"Java后端开发","slug":"Java后端开发","permalink":"https://azoker.top/categories/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"TomCat","slug":"TomCat","permalink":"https://azoker.top/tags/TomCat/"},{"name":"文件上传","slug":"文件上传","permalink":"https://azoker.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"使用POI进行复杂Excel表导入导出","slug":"代码/Demo/使用POI进行复杂Excel表导入导出","date":"2024-08-28T03:08:49.000Z","updated":"2024-10-28T02:59:23.638Z","comments":true,"path":"2024/08/28/代码/Demo/使用POI进行复杂Excel表导入导出/","link":"","permalink":"https://azoker.top/2024/08/28/%E4%BB%A3%E7%A0%81/Demo/%E4%BD%BF%E7%94%A8POI%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%9D%82Excel%E8%A1%A8%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"本人实习阶段做的Excel表导入导出。","text":"待更新……","categories":[{"name":"代码","slug":"代码","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/"},{"name":"Demo","slug":"代码/Demo","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/Demo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"POI","slug":"POI","permalink":"https://azoker.top/tags/POI/"}]},{"title":"关于微信开发者工具抽风的问题","slug":"工具/微信开发者工具/关于微信开发者工具抽风的问题","date":"2024-08-26T03:41:13.000Z","updated":"2024-08-26T05:23:42.499Z","comments":true,"path":"2024/08/26/工具/微信开发者工具/关于微信开发者工具抽风的问题/","link":"","permalink":"https://azoker.top/2024/08/26/%E5%B7%A5%E5%85%B7/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E6%8A%BD%E9%A3%8E%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"关于微信开发者工具，如果不是关于代码逻辑的问题，首先清除缓存重启工具，大概能解决问题。","text":"如果你遇到下面的问题： app.json [文件内容错误] app.json: 未找到 [“pages”][1] 对应的 pages&#x2F;categories&#x2F;categories.wxml 文件 Page ‘pages&#x2F;index&#x2F;index’ has not been registered yet 很多时候都是可以清除缓存重启开发者工具解决问题，如果不行，请核对代码命名。","categories":[{"name":"工具","slug":"工具","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"微信开发者工具","slug":"工具/微信开发者工具","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://azoker.top/tags/BUG/"},{"name":"微信开发者工具","slug":"微信开发者工具","permalink":"https://azoker.top/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"uniapp/vue3/使用pinia","slug":"语言/Vue/uniapp-vue3-使用pinia","date":"2024-08-23T07:48:45.000Z","updated":"2024-08-26T03:05:26.283Z","comments":true,"path":"2024/08/23/语言/Vue/uniapp-vue3-使用pinia/","link":"","permalink":"https://azoker.top/2024/08/23/%E8%AF%AD%E8%A8%80/Vue/uniapp-vue3-%E4%BD%BF%E7%94%A8pinia/","excerpt":"pinia是vuex的升级版，作用是持久化存储，可以想想ThreadLocal的作用。","text":"1.说明uniapp自带pinia，我们并不需要额外去安装，但是要在main.js中引入。 2.引入pinia 打开main.js，没有引入uviewplus需要先引入。 12345678910111213141516// 引入uviewplusimport uviewPlus from &#x27;uview-plus&#x27;// 引入piniaimport * as Pinia from &#x27;pinia&#x27;;import &#123; createSSRApp &#125; from &#x27;vue&#x27;export function createApp() &#123; const app = createSSRApp(App) // 要在app创建之后使用 app.use(uviewPlus) // 使用pinia app.use(Pinia.createPinia()); return &#123; app, Pinia // 必须返回pinia &#125;&#125; 3.使用在根目录下创建store目录，在store目录下新建user.js： 1234567891011121314import &#123; defineStore&#125; from &#x27;pinia&#x27;//创建用户小仓库const useUserStore = defineStore(&#x27;User&#x27;, &#123; state: () =&gt; &#123; return &#123; count: 0 &#125; &#125;&#125;)//暴露用户小仓库export default useUserStore 在某个页面我们去写个事件： 12345678910111213141516// index.vue&lt;template&gt; &lt;view&gt; &lt;up-button type=&quot;primary&quot; :plain=&quot;true&quot; :hairline=&quot;true&quot; text=&quot;细边&quot; @click=&quot;add()&quot;&gt;&#123;&#123; useStore.count &#125;&#125;&lt;/up-button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script setup&gt; //引入用户相关的小仓库 import useUserStore from &#x27;@/store/user.js&#x27; const useStore = useUserStore() //定义button点击事件add const add = () =&gt; &#123; console.log(useStore.count++); &#125;&lt;/script&gt; 自行测试：","categories":[{"name":"语言","slug":"语言","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Vue","slug":"语言/Vue","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://azoker.top/tags/Vue/"}]},{"title":"Vue核心概念","slug":"语言/Vue/Vue核心概念","date":"2024-08-23T03:32:44.000Z","updated":"2024-08-23T07:06:12.585Z","comments":true,"path":"2024/08/23/语言/Vue/Vue核心概念/","link":"","permalink":"https://azoker.top/2024/08/23/%E8%AF%AD%E8%A8%80/Vue/Vue%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"本文主要是针对后端开发，解释一些名词以及Vue的一些设计思想。","text":"VuexVuex是一个专为Vue.js应用程序开发的状态管理模式。简而言之就是用来存数据，可以有效减少使用组件传参困扰的头痛。 基本元素： store里面存数据 mutation里面修改数据 action里面异步调用mutation来修改数据 getter获取数据 如果您熟悉后端开发的话，可以思考ThreadLocal的作用，当然它们并不是一个概念。","categories":[{"name":"语言","slug":"语言","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Vue","slug":"语言/Vue","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://azoker.top/tags/Vue/"}]},{"title":"在uniapp/vue3项目中自定义底部导航栏","slug":"代码/Demo/在uniapp项目中自定义底部导航栏","date":"2024-08-23T03:25:00.000Z","updated":"2024-08-27T01:06:42.823Z","comments":true,"path":"2024/08/23/代码/Demo/在uniapp项目中自定义底部导航栏/","link":"","permalink":"https://azoker.top/2024/08/23/%E4%BB%A3%E7%A0%81/Demo/%E5%9C%A8uniapp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/","excerpt":"使用uniapp项目，做小程序底部的导航栏，点击可以跳转页面。","text":"1.component&#x2F;tarbar.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;view&gt; &lt;u-tabbar :active=&quot;useStore.activeTab&quot; :fixed=&quot;true&quot; :placeholder=&quot;true&quot; :safeAreaInsetBottom=&quot;true&quot;&gt; &lt;u-tabbar-item v-for=&quot;(item, index) in tabbarItems&quot; :key=&quot;index&quot; :icon=&quot;getTabbarIcon(item, index)&quot; :text=&quot;item.text&quot; @click=&quot;handleTabbarItemClick(item, index)&quot;&gt; &lt;/u-tabbar-item&gt; &lt;/u-tabbar&gt; &lt;/view&gt;&lt;/template&gt;&lt;script setup&gt; //引入pinia仓库 import useTarBarStore from &#x27;@/store/tarbar.js&#x27; let useStore = useTarBarStore() const tabbarItems = [&#123; pagePath: &#x27;/pages/index/index&#x27;, text: &#x27;首页&#x27;, iconPath: &#x27;/static/tabBar/home.png&#x27;, selectedIconPath: &#x27;/static/tabBar/home.png&#x27; &#125;, &#123; pagePath: &#x27;/pages/categories/categories&#x27;, text: &#x27;分类&#x27;, iconPath: &#x27;/static/tabBar/category.png&#x27;, selectedIconPath: &#x27;/static/tabBar/category.png&#x27; &#125;, &#123; pagePath: &#x27;/pages/found/found&#x27;, text: &#x27;发现&#x27;, iconPath: &#x27;/static/tabBar/found.png&#x27;, selectedIconPath: &#x27;/static/tabBar/found.png&#x27; &#125; ] //点击tabbar按钮 const handleTabbarItemClick = (item, index) =&gt; &#123; //如果点击了别的tarbar按钮 if (useStore.activeTab !== index) &#123; //设置新按钮 useStore.setActive(index) const path = item.pagePath //uniapp的官方api，切换页面，这个path必须是tarbar的path uni.switchTab(&#123; url: path &#125;) &#125; &#125; //图标的切换，就是点击之后图标会切换，如果有需求可以看看 const getTabbarIcon = (item, index) =&gt; &#123; return useStore.activeTab === index ? item.selectedIconPath : item.iconPath &#125;&lt;/script&gt; 配置点击之后的事件，按钮的切换，路由的切换。可以看到按钮的索引是保存在pinia的，因为是全局的。 2.创建pinia仓库store/tarbar.js： 1234567891011121314151617181920import &#123; defineStore&#125; from &#x27;pinia&#x27;//创建useTarbarStoreconst useTarbarStore = defineStore(&#x27;Tarbar&#x27;, &#123; state: () =&gt; &#123; return &#123; activeTab: 1 // 默认选中的索引 &#125; &#125;, actions: &#123; //设置active的值 setActive(active) &#123; this.activeTab = active &#125; &#125;&#125;)//暴露export default useTarbarStore 这个active是tarbar来标识索引的，不同tarbar有唯一的active。 3.配置tarbar路径之前在tarbar.vue配置的是要跳转的路径，这里配置真正的路径。在page.json新增一个tarbar： 12345678910111213141516&#123; // 省略其他元素... &quot;tabBar&quot;: &#123; // 设置底部 tab 的表现 &quot;color&quot;: &quot;#333333&quot;, &quot;selectedColor&quot;: &quot;#fa2c19&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;backgroundColor&quot;: &quot;#fff&quot;, &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/index/index&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/categories/categories&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/found/found&quot; &#125;] &#125;&#125; 只需要路径即可，其他自行DIY。 4.引入tarbar在需要使用的页面引入tabbar组件： 123456&lt;template&gt; &lt;view&gt; &lt;!-- 引入导航栏tabbar组件 --&gt; &lt;tabbar&gt;&lt;/tabbar&gt; &lt;/view&gt;&lt;/template&gt; 隐藏pages.json里配置的导航栏，使用封装的tabbar组件，在App.vue根组件中编辑： 1234567891011121314151617&lt;script&gt; export default &#123; onLaunch: function() &#123; console.log(&#x27;App Launch&#x27;) &#125;, onShow: function() &#123; console.log(&#x27;App Show&#x27;) //⭐隐藏pages.json里配置的导航栏，使用封装的tabbar组件 uni.hideTabBar(&#123; animation: false &#125;) &#125;, onHide: function() &#123; console.log(&#x27;App Hide&#x27;) &#125; &#125;&lt;/script&gt;","categories":[{"name":"代码","slug":"代码","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/"},{"name":"Demo","slug":"代码/Demo","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/Demo/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://azoker.top/tags/uniapp/"}]},{"title":"uniapp/vue3/通过npm引入uview-plus","slug":"语言/Vue/uniapp-vue3-通过npm引入uview","date":"2024-08-22T08:58:26.000Z","updated":"2024-08-23T06:05:26.129Z","comments":true,"path":"2024/08/22/语言/Vue/uniapp-vue3-通过npm引入uview/","link":"","permalink":"https://azoker.top/2024/08/22/%E8%AF%AD%E8%A8%80/Vue/uniapp-vue3-%E9%80%9A%E8%BF%87npm%E5%BC%95%E5%85%A5uview/","excerpt":"uview对于后端开发来说可能不是特别常见，但是想必一定听过element ui的大名。uview和element ui的作用相同，都是对前端组件的封装，我们按照需要去使用即可。只是element ui针对vue，uview针对uniapp而已。","text":"uview说明uview对于后端开发来说可能不是特别常见，但是想必一定听过element ui的大名。uview和element ui的作用相同，都是对前端组件的封装，我们按照需要去使用即可。只是element ui针对vue，uview针对uniapp而已。 注意事项我要提前说明几点： uniapp引入uview会根据版本不同，项目不同而有很大差异，我使用的是hbuilder软件新建uniapp的项目，然后在控制台通过npm下载uview，然后自己写配置来使用uview。并且我使用的版本是vue3&#x2F;uview-plus3.x，当然uniapp选择的是空白项目。 差异表现为写的配置信息不一样，一定要注意甄别。 官方推荐使用easycom，笔者也认为使用easycom较好。easycom是什么？可以往下看。 如果您不了解vue，笔者建议可以去入个门。 关于SCSSuView依赖SCSS，您必须要安装此插件，否则无法正常运行。 如果您的项目是由HBuilder X创建的，相信已经安装scss插件，如果没有，请在HX菜单的 工具-&gt;插件安装中找到”scss&#x2F;sass编译”插件进行安装， 如不生效，重启HX即可。 如果您的项目是由vue-cli创建的，请通过以下命令安装对sass(scss)的支持，如果已安装，请略过。 12345// 安装sassnpm i sass -D// 安装sass-loader，注意需要版本10，否则可能会导致vue与sass的兼容问题而报错npm i sass-loader@10 -D uview安装安装命令12345678npm install uview-plus# 其他依赖库npm install dayjsnpm install clipboard# 更新# npm update uview-plus 引入 下面文件的路径uniapp和vue-cli的路径不一样，但是这些文件对于后端开发来说应该都不会陌生，更不提前端。 12345678910111213// main.jsimport uviewPlus from &#x27;uview-plus&#x27;// #ifdef VUE3import &#123; createSSRApp &#125; from &#x27;vue&#x27;export function createApp() &#123; const app = createSSRApp(App) app.use(uviewPlus) //要在创建app之后使用 return &#123; app &#125;&#125;// #endif uni.scss12/* uni.scss */@import &#x27;uview-plus/theme.scss&#x27;; App.vue在App.vue中首行的位置引入，注意给style标签加入lang&#x3D;”scss”属性。 1234&lt;style lang=&quot;scss&quot;&gt; /* 注意要写在第一行，同时给style标签加入lang=&quot;scss&quot;属性 */ @import &quot;uview-plus/index.scss&quot;;&lt;/style&gt; easycom配置easycom可以使得在任何页面可以不用导入直接就能使用uview组件。 3.x配置在page.json配置。 1234567891011121314151617// pages.json&#123; &quot;easycom&quot;: &#123; &quot;autoscan&quot;: true, // 注意一定要放在custom里，否则无效，https://ask.dcloud.net.cn/question/131175 &quot;custom&quot;: &#123; &quot;^u--(.*)&quot;: &quot;uview-plus/components/u-$1/u-$1.vue&quot;, &quot;^up-(.*)&quot;: &quot;uview-plus/components/u-$1/u-$1.vue&quot;, &quot;^u-([^-].*)&quot;: &quot;uview-plus/components/u-$1/u-$1.vue&quot; &#125; &#125;, // 此为本身已有的内容 &quot;pages&quot;: [ // ...... ]&#125; 注意：配置完之后需要重启项目！ TS支持在tsconfig.json中参考如下配置增加”uview-plus&#x2F;types”。 123456789101112131415&#123; &quot;compilerOptions&quot;: &#123; &quot;sourceMap&quot;: true, &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;./src/*&quot;] &#125;, &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;], &quot;types&quot;: [ &quot;@dcloudio/types&quot;, &quot;uview-plus/types&quot; ] &#125;, &quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;]&#125; uview使用uview官网","categories":[{"name":"语言","slug":"语言","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Vue","slug":"语言/Vue","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/Vue/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://azoker.top/tags/uniapp/"},{"name":"Vue","slug":"Vue","permalink":"https://azoker.top/tags/Vue/"},{"name":"环境配置","slug":"环境配置","permalink":"https://azoker.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"uview","slug":"uview","permalink":"https://azoker.top/tags/uview/"}]},{"title":"Java基础语法","slug":"语言/Java/Java基础语法","date":"2024-08-21T01:14:48.000Z","updated":"2024-08-21T01:22:37.377Z","comments":true,"path":"2024/08/21/语言/Java/Java基础语法/","link":"","permalink":"https://azoker.top/2024/08/21/%E8%AF%AD%E8%A8%80/Java/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Java关键字 abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new null package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while Java标识符所有Java组件都需要名称。 用于类，变量和方法的名称称为标识符。在Java中，标识符的命名有几点要记住。 它们如下 - 所有标识符都应以字母(A到Z或a到z)，货币字符($)或下划线(_)开头。 在第一个字符之后，标识符可以是任何字符组合。 关键字不能用作标识符。 标识符区分大小写。 合法标识符的示例：age，$salary，_value，__1_value。 非法标识符的示例：123abc，-salary。 注 - Java使用的是uicode编码，是可以用中文命名的，不过笔者建议别用中文。 Java程序规范关于Java程序，请务必牢记以下几点。 区分大小写 - Java区分大小写，因此标识符Hello和hello在Java中具有不同的含义。 类名 - 对于所有类名，第一个字母应为大写。 如果使用多个单词来形成类的名称，则每个内部单词的第一个字母应为大写。示例：class MyFirstJavaClass 方法名称 - 所有方法名称都应以小写字母开头。如果使用多个单词来形成方法的名称，那么每个内部单词的第一个字母应该是大写字母。示例：public void myMethodName() 程序文件名 - 程序文件的名称应与类名完全匹配。保存文件时，应使用类名保存它(记住Java区分大小写)并在名称的末尾使用扩展名称：.java(如果文件名和类名不匹配，则程序将无法编译))。但请注意，如果代码文件中没有public class，则文件名可能与类名不同。在代码文件中也没有强制要求必须有public class。示例：假设MyFirstJavaProgram是类名，那么该文件应保存为：MyFirstJavaProgram.java。 public static void main(String args[]) − Java程序处理从main()方法开始，该方法是每个Java程序的必需部分。 Hello,World!12345678910111213141516171819202122/** * 类名命名规范 * 尽量使用中文，首字母尽量大写，文件名尽量和类名相同 */class HelloJava&#123; /* 方法名单词首字母大写，但开头为小写 */ public void printHelloJava()&#123; System.out.println(&quot;hello,java!&quot;); &#125; // 结果为 - // hello public static void main(String[] args)&#123; new HelloJava().printHelloJava(); &#125;&#125;/*命令行编译命令 javac HelloJava.java命令行运行命令 java HelloJava*/ 注意，可能在使用javac报错： 1234错误 - 编码GBK的不可映射字符原因 - 命令行是GBK，编辑器是UTF-8解决办法 - 带上参数如下：javac -encoding UTF-8 HelloJava.java Java枚举枚举是在Java 5.0中引入的。 枚举将变量限制为仅具有少数预定义值之一。此枚举列表中的值称为枚举。通过使用枚举，可以减少代码中的错误数量。 例如，在新鲜果汁店中，可将玻璃杯大小限制为：小杯，中杯和大杯。 这将确保它不允许购买除了小杯，中杯或大杯之外的玻璃杯。 示例代码： 1234567891011121314class FreshJuice &#123; // 定义枚举 enum FreshJuiceSize&#123; SMALL, MEDIUM, LARGE &#125; FreshJuiceSize size;&#125;public class FreshJuiceTest &#123; public static void main(String args[]) &#123; FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.MEDIUM ; System.out.println(&quot;玻璃杯大小: &quot; + juice.size); &#125;&#125; 编译并执行上面示例代码，得到以下结果： 1玻璃杯大小: MEDIUM 注 - 枚举可以单独声明或在类中声明。 方法，变量，构造函数也可以在枚举内定义。 Java修饰符修饰符是一种添加到定义以更改其含义的关键字。Java语言有各种各样的修饰符，包括以下两种： Java访问修饰符 - 例如：private,protected,public等。 Java非访问修饰符 - 例如：static,final等。 要使用修饰符，请在类，方法或变量的定义中包含修饰符关键字。 修饰符位于语句之前，如下例所示： 1234567891011public class className &#123; // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123; // body of method&#125; 访问控制修饰符Java提供了许多访问修饰符来设置类，变量，方法和构造函数的访问级别。 四个访问级别是： private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 public : 对所有类可见。使用对象：类、接口、变量、方法 强制执行以下继承方法规则： 在超类中声明为public的方法也必须在所有子类中都是public。 在超类中声明为protected的方法必须在子类中也要声明为：protected或public; 不能声明为：private。 声明为private的方法根本不能被继承，因此没有规则。 非访问修饰符Java提供了许多非访问修饰符来实现许多其他功能。 用于创建类方法和变量的static修饰符。 用于完成类，方法和变量的实现的final修饰符。 用于创建抽象类和方法的abstract修饰符。 synchronized和volatile修饰符，用于线程。 static修饰符静态变量static关键字用于创建独立于类实例的变量。无论类的实例数有多少个，都只存在一个静态变量副本。静态变量也称为类变量。局部变量不能声明为static。 静态方法static关键字用于创建独立于类实例的方法。静态方法不能使用作为类的对象的实例变量，静态方法也叫作类方法。静态方法从参数中获取所有数据并从这些参数计算某些内容，而不引用变量。可以使用类名后跟一个点(.)以及变量或方法的名称来访问类变量或方法。 static修饰符用于创建类方法和变量，如下例所示： 123456789101112131415161718192021222324252627public class InstanceCounter &#123; private static int numInstances = 0; protected static int getCount() &#123; return numInstances; &#125; private static void addInstance() &#123; numInstances++; &#125; InstanceCounter() &#123; InstanceCounter.addInstance(); &#125; public static void main(String[] arguments) &#123; System.out.println(&quot;Starting with &quot; + InstanceCounter.getCount() + &quot; instances&quot;); for (int i = 0; i &lt; 500; ++i) &#123; new InstanceCounter(); &#125; System.out.println(&quot;Created &quot; + InstanceCounter.getCount() + &quot; instances&quot;); &#125;&#125; 执行上面示例代码，得到以下结果： 12Started with 0 instancesCreated 500 instances final修饰符final变量final变量只能显式地初始化一次，声明为final的引用变量永远不能重新分配以引用不同的对象。但是，可以更改对象内的数据。 因此，可以更改对象的状态，但不能更改引用。对于变量，final修饰符通常与static一起使用，以使常量成为类变量。 1234567891011public class Test &#123; final int value = 10; // 以下是声明常量的示例： public static final int BOXWIDTH = 6; static final String TITLE = &quot;Manager&quot;; public void changeValue() &#123; value = 12; // 会出错，不能重新赋值 &#125;&#125; final方法任何子类都不能覆盖final方法。 如前所述，final修饰符可防止在子类中修改方法。 声明final方法的主要目的是不让其它人改变方法的内容。 可以在类声明中使用final修饰符声明方法，如下例所示： 12345public class Test &#123; public final void changeName() &#123; // 方法主体 &#125;&#125; final类使用声明为final的类的主要目的是防止类被子类化。 如果一个类被标记为final，那么这个类不能被其它类继承。 示例 123public final class Test &#123; // body of class&#125; abstract修饰符抽象类抽象(abstract)类不能实例化。如果一个类声明为抽象(abstract)，那么唯一的目的是扩展该类。 一个类不能是同时是abstract和final(因为final类不能被扩展)。 如果一个类包含抽象方法，那么该类应该被声明为abstract。 否则，将抛出编译错误。 抽象类可以包含抽象方法以及普通方法。 12345678abstract class Caravan &#123; private double price; private String model; private String year; public void getYear(String y)&#123;&#125;；// 这是一个普通方法 public abstract void goFast(); // 这是一个抽象方法 public abstract void changeColor();// 这是一个抽象方法&#125; 抽象方法抽象方法是在没有任何实现的情况下声明的方法。 方法体(实现)由子类提供。 抽象方法永远不会是最终的或严格的。 扩展抽象类的任何类都必须实现超类的所有抽象方法，除非子类也是抽象类。 如果一个类包含一个或多个抽象方法，那么该类必须声明为abstract。 抽象类不需要包含抽象方法。 抽象方法以分号结尾。 示例：public abstract sample(); 12345678910public abstract class SuperClass &#123; abstract void m(); // 抽象方法&#125;class SubClass extends SuperClass &#123; // 实现抽象方法 void m() &#123; // 实现代码......... &#125;&#125; synchronized修饰符synchronized关键字用于指示一次只能访问一个方法的方法。synchronized修饰符可以应用于四个访问级别修饰符中的任何一个。 123public synchronized void showDetails() &#123; .......&#125; transient修饰符实例变量标记为transient，表示JVM在序列化包含它的对象时跳过特定变量。 此修饰符包含在创建变量的语句中，位于变量的类或数据类型之前。 12public transient int limit = 55; // will not persistpublic int b; // will persist volatile修饰符volatile修饰符用于让JVM知道访问变量的线程必须始终将其自己的变量私有副本与内存中的主副本合并。 访问volatile变量会同步主内存中变量的所有缓存复制。 volatile只能应用于实例变量，类型为private。 volatile对象引用可以为null。 1234567891011121314public class MyRunnable implements Runnable &#123; private volatile boolean active; public void run() &#123; active = true; while (active) &#123; // line 1 // some code here &#125; &#125; public void stop() &#123; active = false; // line 2 &#125;&#125; 通常，在一个线程(使用Runnable开始的线程)中调用run()，并从另一个线程调用stop()。 如果在第1行中使用了active的缓存值，那么当在第2行中将active设置为false时，循环可能不会停止。 Java变量变量提供了程序可以操作的命名存储。 Java中的每个变量都有一个类型，它决定了变量内存的大小和布局; 可以存储在该存储器中的值的范围; 以及可以应用于变量的操作集。 变量需要先声明才能使用，以下是变量声明的基本形式 - 1data type variable [ = value][, variable [ = value] ...] ; 这里data type是Java的数据类型之一，variable是变量的名称。要声明具有相同类型的多个变量，可以使用逗号分隔列表。 以下是Java中变量声明和初始化的示例 - 12345int a, b, c; // 声明三个int类型变量：a, b 和 cint a = 10, b = 10; // 初始化它们的值byte B = 22; // 声明并初始化一个 byte 类型的变量：Bdouble pi = 3.14159; // 声明并赋值一个 double 类型的变量：pichar a = &#x27;a&#x27;; // 声明char类型变量 a，并初始化值为：&#x27;a&#x27; Java中有三种变量 - 局部变量 实例变量 类&#x2F;静态变量 局部变量 局部变量一般在方法，构造函数或块中声明。 程序进入方法，构造函数或块时会创建局部变量，并且一旦退出方法，构造函数或块，变量就会销毁。 访问修饰符不能用于局部变量。 局部变量仅在声明的方法，构造函数或块中可见。 局部变量在内部实现堆栈级别。 局部变量没有默认值，因此应声明局部变量后，在第一次使用之前为它分配初始值。 在这里，age是一个局部变量。 这是在dogAge()方法中定义的，它的范围仅限于此方法。 123456789101112public class Test &#123; public void dogAge() &#123; int age = 0; age = age + 5; System.out.println(&quot;Dog age is : &quot; + age); &#125; public static void main(String args[]) &#123; Test test = new Test(); test.dogAge(); &#125;&#125; 执行上面示例代码，得到以下结果： 1Dog age is : 5 下面示例中使用变量 age ，但不初始化它，因此在编译时会出错。 123456789101112public class Test &#123; public void dogAge() &#123; int age; age = age + 5; System.out.println(&quot;Dog age is : &quot; + age); &#125; public static void main(String args[]) &#123; Test test = new Test(); test.dogAge(); &#125;&#125; 执行上面示例代码，得到以下结果(出错)： 1234Test.java:4:variable number might not have been initializedage = age + 5; ^1 error 实例变量 实例变量在类中声明，但在方法，构造函数或块之外。 为堆中的对象分配空间时，将为每个实例变量值创建一个槽。 使用关键字new创建对象时会创建实例变量，并在销毁对象时销毁实例变量。 实例变量包含由多个方法，构造函数或块引用的值，或者在整个类中存在的对象状态的基本部分。 实例变量可以在使用之前或之后在类级别中声明。 可以为实例变量给出访问修饰符。 实例变量对于类中的所有方法，构造函数和块都是可见的。 通常，建议将这些变量设为私有(访问级别)。 但是，可以使用访问修饰符为这些变量提供子类的可见性。 实例变量具有默认值。 对于数字，默认值为0，对于布尔值，它为false，对于对象引用，它为null。 可以在声明期间或构造函数中指定值。 可以通过调用类中的变量名来直接访问实例变量。 但是，在静态方法中(当实例变量具有可访问性时)，应使用完全限定名称调用它们，如：ObjectReference.VariableName。 12345678910111213141516171819202122232425262728293031import java.io.*;public class Employee &#123; // 此实例变量对于子类都是可见的。 public String name; // salary 变量仅在Employee类中可见。 private double salary; // name变量在构造函数中指定。 public Employee (String empName) &#123; name = empName; &#125; // 为 salary 变量赋值 public void setSalary(double empSal) &#123; salary = empSal; &#125; // 此方法打印员工详细信息。 public void printEmp() &#123; System.out.println(&quot;name : &quot; + name ); System.out.println(&quot;salary :&quot; + salary); &#125; public static void main(String args[]) &#123; Employee empOne = new Employee(&quot;Maxsu&quot;); empOne.setSalary(15999); empOne.printEmp(); &#125;&#125; 执行上面示例代码，得到以下结果： 12name : Maxsusalary :15999.0 类&#x2F;静态变量 类变量(也称为静态变量)在类中使用static关键字声明，但在方法，构造函数或块之外。 每个类只有一个每个类变量的副本，无论从中创建多少个对象。 除了声明为常量之外，很少使用静态变量。常量是声明为public/private，final和static的变量。常量的初始值不能更改。 静态变量存储在静态存储器中。 除了声明的final之外，很少使用静态变量，并将其用作公共或私有常量。 程序启动时会创建静态变量，程序停止时会销毁静态变量。 可见性类似于实例变量。 但是，大多数静态变量都是公共的，因为它们必须可供该类用户使用。 默认值与实例变量相同。 对于数字，默认值为0; 对于布尔类型来说，默认值为false; 对于对象引用，默认值为null。 可以在声明期间或构造函数中指定值。 此外，可以在特殊的静态初始化程序块中分配值。 可以通过使用类名ClassName.VariableName调用来访问静态变量。 将类变量声明为public static final时，变量名(常量)都是大写的。 如果静态变量不是public和final，则命名语法与实例和局部变量命名规则相同。 1234567891011121314import java.io.*;public class Employee &#123; // salary变量是一个私有静态变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = &quot;研发部&quot;; public static void main(String args[]) &#123; salary = 19999; System.out.println(DEPARTMENT + &quot;平均薪水:&quot; + salary); &#125;&#125; 执行上面示例代码，得到以下结果 - 1研发部平均薪水:19999 注 - 如果从外部类访问变量，则应作为：Employee.DEPARTMENT。 Java基本数据类型变量是用于存储值的保留内存位置。当创建变量时，它会在内存中保留一些空间。 根据变量的数据类型，操作系统分配内存并决定可以存储在保留内存中的内容。 因此，通过为变量分配不同的数据类型，可以在这些变量中存储整数，小数或字符。 Java中有两种数据类型 - 原始数据类型 引用&#x2F;对象数据类型 原始数据类型Java支持八种原始数据类型。 原始数据类型由语言预定义，并由关键字命名。下面来详细了解和学习这八种原始数据类型。 类型 描述 值范围 默认值 示例 byte 表示8位有符号二进制补码整数 -128 (-2^7) - 127 (2^7 -1) 0 byte a = 100, byte b = -50 short 表示16位有符号二进制补码整数 -2^15-2^15 -1 0 short s = 10000, short r = -20000 int 表示32位有符号二进制补码整数 -2^31-2^31 -1 0 int a = 100000, int b = -200000 long 表示64位带符号的二进制补码整数 -2^63-2^63 -1 0L long a = 100000L, long b = -200000L float 表示单精度32位IEEE 754浮点数 - 0.0f float f1 = 234.5f double 表示双精度64位IEEE 754浮点数 - 0.0d double d1 = 123.4 boolean 表示一个比特位的信息 true&#x2F;false false boolean one = true char 表示单个16位Unicode字符 \\u0000-\\uffff - char letterA = &#39;A&#39; 引用数据类型 使用类中已定义构造函数创建引用变量。 它们用于访问对象。 声明这些变量属于无法更改的特定类型。 例如，Employee，Dog类等。 类对象和各种类型的数组变量属于引用数据类型。 任何引用变量的默认值为null。 引用变量可用于引用声明类型的任何对象或任何兼容类型。 示例：Dog dog = new Dog(&quot;旺财&quot;); Java文字文字是固定值的源代码表示。它们直接在代码中表示，无需任何计算。可以将文字分配给任何基本类型变量。 例如 - 12byte a = 68;char a = &#x27;A&#x27;; byte，int，long和short也可以用十进制(基数为10)，十六进制(基数16)或八进制(基数8)数字表示。 前缀0b用于表示二进制，前缀0用于表示八进制，前缀0x表示使用这些数字系统进行文字时的十六进制。 例如 - 1234int binary = 0b11; // 二进制int decimal = 100; // 十进制int octal = 0144; // 八进制int hexa = 0x64; // 十六进制 Java中的字符串文字通过在一对双引号之间包含一系列字符来指定，就像它们在大多数其他编程语言中一样。 字符串文字的例子是 - 123&quot;Hello World&quot;&quot;two\\nlines&quot;&quot;&quot;This is in quotes&quot;&quot; 字符串和字符类型的文字可以包含任何Unicode字符。 例如 - 12char a = &#x27;\\u0001&#x27;;String a = &quot;\\u0001&quot;; Java语言也支持String和char文字的几个特殊转义序列。它们是 - 符号 代表的字符 \\n 换行符(0x0a) \\r 回车(0x0d) \\f 换页(0x0c) \\b 退格(0x08) \\s 空格(0x20) \\t 制表符 \\&quot; 双引号 \\&#39; 单引号 \\\\ 反斜线 \\ddd 八进制字符(ddd) \\uxxxx 十六进制UNICODE字符(xxxx) Java数组数组是存储多个相同类型变量的对象。 但是，数组本身是堆上的对象。 Java提供了一种叫作数组的数据结构，它是一种用来存储相同类型元素的固定大小顺序集合。 数组用于存储数据集合，但也可以将数组视为相同类型的变量集合。 声明一个数组变量(如：numbers)并使用numbers[0]，numbers[1]和...，numbers[99]来表示单个变量，例如number0，number1，...和number99，而不是单独地声明各个变量。 本教程介绍如何声明数组变量，创建数组和索引访问数组。 声明数组变量要在程序中使用数组，需要先声明一个变量以引用该数组，并且要指定该变量的数组类型。 以下是声明数组变量的语法 - 123dataType[] arrayRefVar; // 推荐方式。// 或者dataType arrayRefVar[]; // 有效，但不是推荐方式。 注 - 格式：dataType [] arrayRefVar是推荐方式。 格式：dataType arrayRefVar []来自C&#x2F;C++语言，可在Java中采用以适应C&#x2F;C++程序员。 以下代码片段是此语法的示例 - 123double[] myList; // 推荐方式。// 或者double myList[]; // 有效，但不是推荐方式。 创建数组可以使用new运算符来创建数组，如以下语法 - 1234// 声明dataType[] arrayRefVar; // 推荐方式。// 创建arrayRefVar = new dataType[arraySize]; 上面语句做了两件事 - 它使用new dataType[arraySize]来创建了一个数组。 它将新创建的数组的引用分配给变量arrayRefVar。 声明一个数组变量，创建一个数组，并将该数组的引用分配给变量，可以在一个语句中完成，如下所示 - 1dataType[] arrayRefVar = new dataType[arraySize]; 或者，可以按如下方式创建数组 - 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 通过索引访问数组元素。 数组索引值从0开始; 也就是说，它们从0开始到arrayRefVar.length - 1。 下面语句中声明了一个数组变量myList，它创建了一个包含10个double类型元素的数组，并将数组变量的引用分配给myList - 1double[] myList = new double[10]; 下表表示数组myList。 这里，myList数组中包含十个double值，索引从0到9。 数组下标索引 元素的值 myList[0] 5.6 myList[1] 4.5 myList[2] 3.3 myList[3] 13.2 myList[4] 4.0 myList[5] 34.33 myList[6] 34.0 myList[7] 45.45 myList[8] 99.993 myList[9] 11123 处理数组处理数组元素时，经常使用for循环或foreach循环，因为数组中的所有元素都是相同的类型，并且数组的大小是已知的。这是一个完整的示例，演示了如何创建，初始化和处理数组 - 1234567891011121314151617181920212223242526272829import java.util.*;public class Test &#123; public static void main(String[] args) &#123; double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;; // 打印所有元素 for (int i = 0; i &lt; myList.length; i++) &#123; System.out.print(myList[i] + &quot;, &quot;); &#125; System.out.println(&quot; &quot;); // 求和 double total = 0; for (int i = 0; i &lt; myList.length; i++) &#123; total += myList[i]; &#125; System.out.println(&quot;总和：&quot; + total); // 查找最大值 double max = myList[0]; for (int i = 1; i &lt; myList.length; i++) &#123; if (myList[i] &gt; max) max = myList[i]; &#125; System.out.println(&quot;元素最大值：&quot; + max); &#125;&#125; 执行上面示例代码，得到以下结果： 12310.01, 12.19, 23.44, 43.95, 77.88, 65.0, 总和：232.47元素最大值：77.88 foreach循环JDK 1.5引入了foreach循环或增强for循环，它能够在不使用索引变量的情况下顺序遍历整个数组。 以下代码演示如何遍历数组myList中的所有元素 - 12345678910111213import java.util.*;public class Test &#123; public static void main(String[] args) &#123; double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;; // Print all the array elements for (double element : myList) &#123; System.out.print(element+&quot;, &quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 110.01, 12.19, 23.44, 43.95, 77.88, 65.0, 将数组传递给方法就像将原始类型值传递给方法一样，也可以将数组传递给方法。 例如，以下printArray()方法用来打印int数组中的元素 - 1234567891011121314151617import java.util.*;public class Test &#123; public static void main(String[] args) &#123; double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;; // Print all the array elements printArray(myList); &#125; public static void printArray(double[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + &quot; &quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 110.01 12.19 23.44 43.95 77.88 65.0 从方法返回数组方法可以返回数组。 例如，以下方法返回一个与给定参数数组相反的数组 - 12345678910111213141516171819202122232425262728import java.util.*;public class Test &#123; public static void main(String[] args) &#123; double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;; // Print all the array elements printArray(myList); printArray(reverse(myList)); &#125; public static void printArray(double[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125; public static double[] reverse(double[] list) &#123; double[] result = new double[list.length]; for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) &#123; result[j] = list[i]; &#125; return result; &#125;&#125; 执行上面示例代码，得到以下结果： 1210.01 12.19 23.44 43.95 77.88 65.0 65.0 77.88 43.95 23.44 12.19 10.01 Arrays类java.util.Arrays类包含各种静态方法，用于排序和搜索数组，比较数组和填充数组元素。 对于所有基本类型，这些方法都会重载。 方法 描述 public static int binarySearch(Object[] a, Object key) 使用二进制搜索算法搜索指定的Object(Byte，Int，double等)数组以获取指定值。 必须在进行此调用之前对数组进行排序。 如果搜索关键字包含在列表中，则返回搜索关键字的索引; 否则，它返回( -(插入点 + 1))。 public static boolean equals(long[] a, long[] a2) 如果两个指定的long数组相等，则返回true。 如果两个数组包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中的所有相应元素对相等。如果两个数组相等，则返回true。 所有其他原始数据类型(Byte，Short，Int等)可以使用相同的方法。 public static void fill(int[] a, int val) 将指定的int值分配给指定的int数组的每个元素。所有其他原始数据类型(Byte，Short，Int等)可以使用相同的方法。 public static void sort(Object[] a) 根据元素的自然顺序，将指定的对象数组按升序排序。 所有其他原始数据类型(Byte，Short，Int等)可以使用相同的方法。 Java基本运算符Java提供了一组丰富的操作符来操作变量。 我们可以将所有Java运算符划分为以下几个分类 - 算术运算符 关系运算符 按位运算符 逻辑运算符 赋值运算符 其他运算符 算术运算符算术运算符在数学表达式中的使用方式与在代数中使用的方式相同。下表列出了算术运算符的使用示例 - 假设整数类型变量A的值为：10，变量B的值为：20，则 - 运算符 描述 示例 + 加法运算符,第一个操作数加上第二个数操作数 A + B结果为：30 - 减法运算符,从第一个操作数减去第二个操作数 A - B结果为：-10 * 两个操作数相乘 A * B结果为：200 / 左操作数除以右操作数返回模值 B / A结果为：2 % 左操作数除以右操作数返回余数 B / A结果为：0 ++ 将操作数的值增加1 A++，则A的值为：11 -- 将操作数的值减1 A--，则A的值为：9 算术运算符示例代码 - 12345678910111213141516171819202122public class Test &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(&quot;a + b = &quot; + (a + b) ); System.out.println(&quot;a - b = &quot; + (a - b) ); System.out.println(&quot;a * b = &quot; + (a * b) ); System.out.println(&quot;b / a = &quot; + (b / a) ); System.out.println(&quot;b % a = &quot; + (b % a) ); System.out.println(&quot;c % a = &quot; + (c % a) ); System.out.println(&quot;a++ = &quot; + (a++) ); System.out.println(&quot;b-- = &quot; + (a--) ); // 对比 d++ 和 ++d 有什么区别 System.out.println(&quot;d++ = &quot; + (d++) ); System.out.println(&quot;++d = &quot; + (++d) ); &#125;&#125; 执行上面示例代码，得到以下结果： 12345678910a + b = 30a - b = -10a * b = 200b / a = 2b % a = 0c % a = 5a++ = 10b-- = 11d++ = 25++d = 27 关系运算符Java语言支持以下关系运算符。假设变量A的值是10，变量B的值是20，则 - 运算符 描述 示例 == 等于运算符，检查两个操作数的值是否相等，如果相等，则条件变为真。 A==B结果为假。 != 不等于运算符，检查两个操作数的值是否不相等，如果不相等，则条件变为真。 A!=B结果为真。 &gt; 大于运算符，检查左操作数的值是否大于右操作数的值，如果大于，则条件变为真。 A&gt;B结果为假。 &lt; 小于运算符，检查左操作数的值是否小于右操作数的值，如果小于，则条件变为真。 A&lt;B结果为真。 &gt;= 大于或等于运算符，检查左操作数的值是否大于等于右操作数的值，如果大于或等于，则条件变为真。 A&gt;=B结果为假。 &lt;= 小于或等于运算符，检查左操作数的值是否小于或等于右操作数的值，如果小于或等于，则条件变为真。 A&lt;=B结果为真。 Java关系运算符示例代码如下 - 1234567891011121314public class Test &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; System.out.println(&quot;a == b = &quot; + (a == b) ); System.out.println(&quot;a != b = &quot; + (a != b) ); System.out.println(&quot;a &gt; b = &quot; + (a &gt; b) ); System.out.println(&quot;a &lt; b = &quot; + (a &lt; b) ); System.out.println(&quot;b &gt;= a = &quot; + (b &gt;= a) ); System.out.println(&quot;b &lt;= a = &quot; + (b &lt;= a) ); &#125;&#125; 执行上面示例代码，得到以下结果： 123456a == b = falsea != b = truea &gt; b = falsea &lt; b = trueb &gt;= a = trueb &lt;= a = false 按位运算符Java定义了几个按位运算符，可以应用于整数类型， 如：long，int，short，char和byte。按位运算符处理位并执行逐位运算。 假设a = 60且b = 13; 采用二进制格式，它们将如下 - 12345678910111213a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011 下面的表中列出了按位运算符，假设整数变量A=60，变量B=13，那么 - 运算符 描述 示例 &amp; 二进制AND运算符，如果存在于两个操作数中，则它会将结果复制到结果中。 A &amp; B的结果为：12，也就是：0000 1100 Ι 二进制OR运算符，如果存在于任一操作数中，则复制一位。 A Ι B 的结果为：61，也就是：0011 1101 ^ 二进制异或运算符，如果在一个操作数中设置但不在两个操作数中设置，则复制该位。 A ^ B的结果为：49，也就是：0011 0001 ~ 二元一元补充运算符是一元的，具有“翻转”位的效果。 ~A的结果为：-61，也就是：1100 0011 &lt;&lt; 二进制左移运算符，左操作数值向左移动右操作数指定的位数。 A &lt;&lt; 2的结果为：240，也就是：1111 0000 &gt;&gt; 二进制右移运算符，左操作数值向右移动右操作数指定的位数。 A &gt;&gt; 2的结果为：15，也就是：1111 &gt;&gt;&gt; 右移零填充运算符。 左操作数值向右移动右操作数指定的位数，移位值用零填充。 A &gt;&gt;&gt;2的结果为：15，也就是：0000 1111 按位运算符示例代码如下 - 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String args[]) &#123; int a = 60; /* 60 = 0011 1100 */ int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a &amp; b; /* 12 = 0000 1100 */ System.out.println(&quot;a &amp; b = &quot; + c ); c = a | b; /* 61 = 0011 1101 */ System.out.println(&quot;a | b = &quot; + c ); c = a ^ b; /* 49 = 0011 0001 */ System.out.println(&quot;a ^ b = &quot; + c ); c = ~a; /*-61 = 1100 0011 */ System.out.println(&quot;~a = &quot; + c ); c = a &lt;&lt; 2; /* 240 = 1111 0000 */ System.out.println(&quot;a &lt;&lt; 2 = &quot; + c ); c = a &gt;&gt; 2; /* 15 = 1111 */ System.out.println(&quot;a &gt;&gt; 2 = &quot; + c ); c = a &gt;&gt;&gt; 2; /* 15 = 0000 1111 */ System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + c ); &#125;&#125; 执行上面示例代码，得到以下结果： 1234567a &amp; b = 12a | b = 61a ^ b = 49~a = -61a &lt;&lt; 2 = 240a &gt;&gt; 2 = 15a &gt;&gt;&gt; 2 = 15 逻辑运算符下表列出了逻辑运算符 - 假设布尔变量A的值为：true，变量B 的值为：false，则 - 运算符 描述 示例 &amp;&amp; 逻辑AND运算符。 如果两个操作数都不为零，则条件成立。 (A &amp;&amp; B)结果为：false ΙΙ 逻辑OR运算符。 如果两个操作数中的任何一个非零，则条件变为真。 (A ΙΙ B)结果为：true ! 逻辑非运算符。用于反转其操作数的逻辑状态。 如果条件为真，则口逻辑NOT运算符将为false。 !(A &amp;&amp; B)结果为：true 逻辑运算符示例代码如下 - 1234567891011public class Test &#123; public static void main(String args[]) &#123; boolean a = true; boolean b = false; System.out.println(&quot;a &amp;&amp; b = &quot; + (a&amp;&amp;b)); System.out.println(&quot;a || b = &quot; + (a||b) ); System.out.println(&quot;!(a &amp;&amp; b) = &quot; + !(a &amp;&amp; b)); &#125;&#125; 执行上面示例代码，得到以下结果： 123a &amp;&amp; b = falsea || b = true!(a &amp;&amp; b) = true 赋值运算符以下是Java语言支持的赋值运算符 - 运算符 描述 示例 = 简单赋值运算符。 将右侧操作数的值分配给左侧操作数。 C = A + B将A + B的值分配给C。 += 相加与赋值运算符。 它将右操作数相加到左操作数并将结果分配给左操作数。 C += A等于C = C + A。 -= 减去与赋值运算符。 它从左操作数中减去右操作数，并将结果赋给左操作数。 C -= A等于C = C - A。 *= 乘以与赋值运算符。 它将右操作数与左操作数相乘，并将结果赋给左操作数。 C *= A等于C = C * A。 /= 除以与赋值运算符。 它将左操作数除以右操作数，并将结果赋给左操作数。 C /= A等于C = C / A。 %= 模数与赋值运算符。 它使用两个操作数来计算获取模数，并将结果赋给左操作数。 C %= A等于C = C % A。 &lt;&lt;= 左移与赋值运算符。 C &lt;&lt;= 2与C = C &lt;&lt; 2相同 &gt;&gt;= 右移与赋值运算符。 C &gt;&gt;= 2与C = C &gt;&gt; 2相同 &amp;= 按位与赋值运算符。 C &amp;= 2与C = C &amp; 2相同 ^= 按位异或和赋值运算符。 C ^= 2与C = C ^ 2相同 Ι= 按位包含或与赋值运算符。 C Ι&#x3D; 2与C &#x3D; C Ι&#x3D;2相同 赋值运算符示例代码如下 - 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; int c = 0; c = a + b; System.out.println(&quot;c = a + b = &quot; + c ); c += a ; System.out.println(&quot;c += a = &quot; + c ); c -= a ; System.out.println(&quot;c -= a = &quot; + c ); c *= a ; System.out.println(&quot;c *= a = &quot; + c ); a = 10; c = 15; c /= a ; System.out.println(&quot;c /= a = &quot; + c ); a = 10; c = 15; c %= a ; System.out.println(&quot;c %= a = &quot; + c ); c &lt;&lt;= 2 ; System.out.println(&quot;c &lt;&lt;= 2 = &quot; + c ); c &gt;&gt;= 2 ; System.out.println(&quot;c &gt;&gt;= 2 = &quot; + c ); c &gt;&gt;= 2 ; System.out.println(&quot;c &gt;&gt;= 2 = &quot; + c ); c &amp;= a ; System.out.println(&quot;c &amp;= a = &quot; + c ); c ^= a ; System.out.println(&quot;c ^= a = &quot; + c ); c |= a ; System.out.println(&quot;c |= a = &quot; + c ); &#125;&#125; 执行上面示例代码，得到以下结果 - 123456789101112c = a + b = 30c += a = 40c -= a = 30c *= a = 300c /= a = 1c %= a = 5c &lt;&lt;= 2 = 20c &gt;&gt;= 2 = 5c &gt;&gt;= 2 = 1c &amp;= a = 0c ^= a = 10c |= a = 10 其它运算符Java语言支持的其他运算符很少。 条件运算符(?:)条件运算符也称为三元运算符。 此运算符由三个操作数组成，用于计算布尔表达式。 运算符的目标是确定应将哪个值赋给变量。 运算符写成 - 1variable x = (expression) ? value if true : value if false 下面是一段示例代码： 123456789101112public class Test &#123; public static void main(String args[]) &#123; int a, b; a = 10; b = (a == 1) ? 20: 30; System.out.println( &quot;Value of b is : &quot; + b ); b = (a == 10) ? 20: 30; System.out.println( &quot;Value of b is : &quot; + b ); &#125;&#125; 执行上面示例代码，得到以下结果 - 12Value of b is : 30Value of b is : 20 instanceof运算符此运算符仅用于对象引用变量。 运算符检查对象是否属于特定类型(类类型或接口类型)。 instanceof运算符写成 - 1( Object reference variable ) instanceof (class/interface type) 如果操作符左侧的变量引用的对象是右侧的类&#x2F;接口类型，则结果为真。 以下是一个例子 - 1234567891011public class Test &#123; public static void main(String args[]) &#123; String name = &quot;Kobe&quot;; // 当 name 的类型是 String 时，则返回为：true boolean result = name instanceof String; System.out.println( result ); &#125;&#125; 执行上面示例代码，得到以下结果： 1true 如果要比较的对象与右侧类型兼容，则此运算符仍将返回true。 以下是另一个例子 - 1234567891011class Vehicle &#123;&#125;public class Car extends Vehicle &#123; public static void main(String args[]) &#123; Vehicle a = new Car(); boolean result = a instanceof Car; System.out.println( result ); &#125;&#125; 执行上在示例代码，得到以下结果： 1true Java循环控制在程序执行过程中，存在需要多次执行代码块的情况。 通常，语句按顺序执行：首先执行函数中的第一个语句，然后执行第二个语句，依此类推。 编程语言提供各种控制结构，允许更复杂的执行路径。 三大循环Java编程语言提供以下类型的循环来处理循环要求 - 编号 循环 描述 1 while循环 在给定条件为真时重复语句或语句组，它在执行循环体之前测试条件。 2 for循环 多次执行一系列语句，并缩写管理循环变量的代码。 3 do…while循环 像while语句一样，但是它在末端测试循环体的条件。 while循环只要给定条件为真，Java编程语言中的while循环语句就会重复执行目标语句。 语法 while循环的语法是 - 123while(boolean_expression) &#123; // 执行语句&#125; 这里，语句可以是单个语句或语句块。 条件(boolean_expression)可以是任何表达式，true是任何非零值。 执行时，如果boolean_expression结果为true，则执行循环内的操作。只要表达式结果为true，它将继续执行。 示例1. Java while循环这是一个简单的java while循环示例，用于打印5到10之间的数字。 12345678910111213//package com.yiibai.javawhileloop;public class JavaWhileLoop &#123; public static void main(String[] args) &#123; int i = 5; while (i &lt;= 10) &#123; System.out.println(i); i++; &#125; &#125;&#125; 请注意，在循环中增加了i的值，否则while循环永远不会终止，因为它变成了无限循环。 终止程序在无限循环中运行的唯一方法是手动退出它或JVM内存不足时。 请注意，如果布尔表达式返回false，则while循环内的语句将不会执行。 所以while循环中的语句有可能永远不会执行。 示例2. Java迭代循环与迭代器 Java while循环在java中经常与迭代器一起使用。 下面来看一个使用while循环迭代ArrayList的简短示例。 123456789101112131415161718import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class JavaWhileLoop &#123; public static void main(String[] args) &#123; List&lt;String&gt; veggies = new ArrayList&lt;&gt;(); veggies.add(&quot;油麦菜&quot;); veggies.add(&quot;红豆角&quot;); veggies.add(&quot;西红柿&quot;); Iterator&lt;String&gt; it = veggies.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 执行上面示例代码，得到以下结果 - 123油麦菜红豆角西红柿 示例3. while无限循环示例 有时希望循环无限运行。在这种情况下，可以使用while循环。 无限运行的一个例子是在特定位置连续查找文件，如果找到则然后处理它。 下面是java中while循环的伪代码示例。 12345678910111213141516171819202122//package com.yiibai.javawhileloop;public class WhileTrueJava &#123; public static void main(String[] args) &#123; while(true) &#123; System.out.println(&quot;开始处理&quot;); // 在特定目录中查找文件 // 如果找到则处理它，比如将文件信息插入数据库 System.out.println(&quot;结束处理&quot;); // 等待10秒，再继续处理... try &#123; Thread.sleep(10*1000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;Thread Interrupted, exit now&quot;); System.exit(0); &#125; &#125; &#125;&#125; 如果运行上面的程序，需要在终端上使用Ctrl + C手动退出程序。 如果使用的是Eclipse，则会有一个红色按钮来终止当前正在运行的程序。 for循环for循环是一种重复控制结构，用于有效地编写需要执行特定次数的循环。当知道要重复任务的次数时，for循环就很有用。 语法 for循环的语法是 - 123for(initialization; boolean_expression; update) &#123; // Statements&#125; 在上面语法中， 首先执行初始化(initialization)步骤，并且仅执行一次。此步骤用于声明和初始化循环控制变量，此步骤以分号(;)结束。 接下来，计算布尔表达式(boolean_expression)。 如果结果为：true，则执行循环体。 如果为false，则不执行循环体，控制跳转到for循环之后的下一个语句。 在执行for循环体之后，控件跳回到update语句。 此语句用于更新任何循环控制变量。此语句可以留空，最后是分号(;)。 现在再次评估布尔表达式(boolean_expression)。 如果结果为：true，则循环执行并重复该过程(循环体，然后是更新步骤，然后是布尔表达式)。 布尔表达式为false后，for循环终止。 java中有三种类型的for循环，它们分别如下： 简单for循环 for-each或增强for循环 for循环与标签 1. 简单for循环实例 Java中的简单for循环与C&#x2F;C ++相同。可以初始化变量，检查条件和增量&#x2F;减量值。假设要打印5到10的整数，在这种情况下可以使用基本的for循环。 123456789101112//package com.yiibai.javaforloop;public class JavaForLoop &#123; public static void main(String[] args) &#123; //print integers 5 to 10 for (int i=5; i&lt;=10; i++) &#123; System.out.println(&quot;Java for loop example - &quot; + i); &#125; &#125;&#125; 执行上面示例代码，得到以下结果 - 123456Java for loop example - 5Java for loop example - 6Java for loop example - 7Java for loop example - 8Java for loop example - 9Java for loop example - 10 示例2. for增强型循环 Java中的for each循环也称为增强型循环。可以使用for each迭代数组或集合元素。Java for each循环是推荐的循环方式，因为它的代码编写比较简单和紧凑。 1234567891011121314151617181920212223//package com.yiibai.javaforloop;import java.util.ArrayList;import java.util.List;public class JavaForEachLoopExample &#123; public static void main(String[] args) &#123; int[] intArray = &#123; 10, 20, 30, 40, 50 &#125;; for (int i : intArray) System.out.println(&quot;Java for each loop with array - &quot; + i); List&lt;String&gt; fruits = new ArrayList&lt;&gt;(); fruits.add(&quot;苹果&quot;); fruits.add(&quot;香蕉&quot;); fruits.add(&quot;橙子&quot;); for (String f : fruits) System.out.println(&quot;Java for each loop with collection - &quot; + f); &#125;&#125; 执行上面示例代码，得到以下结果 - 12345678Java for each loop with array - 10Java for each loop with array - 20Java for each loop with array - 30Java for each loop with array - 40Java for each loop with array - 50Java for each loop with collection - 苹果Java for each loop with collection - 香蕉Java for each loop with collection - 橙子 从上面的例子中可以看出，如果for循环中只有一个语句，不需要将它们放在花括号&#123;&#125;中。 示例3. for循环与标签 可以在for循环中添加一个标签，它对break和continue语句有用，可以退出外循环。 请注意，默认情况下，break和continue语句仅适用于内部循环。 下面是带有标签的for循环的示例以及它如何与continue语句一起使用。 1234567891011121314151617181920import java.util.Arrays;public class JavaForLoopWithLabel &#123; public static void main(String[] args) &#123; int[][] intArr = &#123; &#123; 1, -2, 3 &#125;, &#123; 0, 3 &#125;, &#123; 1, 2, 5 &#125;, &#123; 9, 2, 5 &#125; &#125;; process: for (int i = 0; i &lt; intArr.length; i++) &#123; boolean allPositive = true; for (int j = 0; j &lt; intArr[i].length; j++) &#123; if (intArr[i][j] &lt; 0) &#123; allPositive = false; continue process; &#125; &#125; if (allPositive) &#123; // process the array System.out.println(&quot;Processing &quot; + Arrays.toString(intArr[i])); &#125; allPositive = true; &#125; &#125;&#125; 执行上面示例代码，得到以下结果 - 123Processing [0, 3]Processing [1, 2, 5]Processing [9, 2, 5] do…while循环 其实笔者基本也只在算法题里面用的比较多 do...while循环类似于while循环，除了do...while循环保证至少执行一次。 语法以下是do...while循环的语法 - 123do &#123; // Statements&#125;while(boolean_expression); 请注意，布尔表达式在循环的末尾，因此循环中的语句在测试布尔值之前已经执行了一次。 如果布尔表达(boolean_expression)式评估结果为true，则控制跳回到do语句，循环中的语句再次执行。 重复此过程，直到布尔表达式(boolean_expression)评估结果为false。 示例1. do…while循环 这是一个简单的java do while循环示例，用于打印5到10之间的数字。 1234567891011121314//package com.yiibai.javadowhileloop;public class JavaDoWhileLoop &#123; public static void main(String[] args) &#123; int i = 5; do &#123; System.out.println(i); i++; &#125; while (i &lt;= 10); &#125;&#125;Java 执行上面示例代码，得到以下结果： 1234565678910 示例2. do…while无限循环 通过在do...while循环中将布尔表达式使用true值来创建无限循环。下面是一个简单的做java无限循环的例子(伪代码)。 123456789101112131415//package com.java.javadowhileloop;public class DoWhileTrueJava &#123; public static void main(String[] args) throws InterruptedException &#123; do &#123; System.out.println(&quot;Start Processing inside do while loop&quot;); // 在指定目录中查找文件 // 如果找到，则处理它，例如：将文件信息插入数据库 System.out.println(&quot;End Processing of do while loop&quot;); Thread.sleep(5 * 1000); // 暂停5秒，接着执行 &#125; while (true); &#125;&#125; 请注意，如果在终端中执行程序，则可使用Ctrl + C手动退出应用程序。 如果已在Eclipse IDE中执行程序，则会有一个红色按钮来终止程序。 do…while与while循环比较 当希望在循环内的语句至少执行一次时，则应该使用do...while循环。 否则，使用while循环总是更好选择。Java while循环看起来比do...while循环更干净。 循环控制语句循环控制语句将执行从正常执行顺序更变。 当执行离开作用域时，将销毁在该作用域中创建的所有自动对象。 Java支持以下控制语句，可通过单击以下每个链接来了解和学习。 编号 控制语句 描述 1 break语句 终止循环或switch语句，并立即将执行转移到在循环或switch之后的语句。 2 continue语句 使循环跳过其主体的其余部分，并在重复之前立即重新测试其状态。 break语句Java编程语言中的break语句有以下两种用法 - 当在循环内遇到break语句时，循环立即终止，程序控制在循环体之后的下一个语句处重新开始。 它可以用于在switch语句中终止一个case。 语法 break的语法是循环内的单个语句 - 1break; 示例1. break简单示例 1234567891011121314public class Test &#123; public static void main(String args[]) &#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers ) &#123; if( x == 30 ) &#123; break; &#125; System.out.print( x ); System.out.print(&quot;\\n&quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果 - 121020 示例2. break语句示例 在这个示例中，演示如何在java的for循环，while循环和do-while循环中使用break语句。 12345678910111213141516171819202122232425262728293031323334353637383940// package com.yiibai.util;public class JavaBreak &#123; public static void main(String[] args) &#123; String[] arr = &#123; &quot;Y&quot;, &quot;I&quot;, &quot;I&quot;, &quot;B&quot;, &quot;A&quot;, &quot;I&quot; &#125;; // 在 for 循环中使用 break for (int len = 0; len &lt; arr.length; len++) &#123; if (arr[len].equals(&quot;I&quot;)) &#123; System.out.println(&quot;Array contains &#x27;I&#x27; at index: &quot; + len); // 当找到字母时使用`break`语句中断循环 break; &#125; &#125; // 在 while 循环中使用 break int len = 0; while (len &lt; arr.length) &#123; if (arr[len].equals(&quot;B&quot;)) &#123; System.out.println(&quot;Array contains &#x27;B&#x27; at index: &quot; + len); // 当找到字母时使用`break`语句中断循环 break; &#125; len++; &#125; len = 0; // 在 do-while循环中使用 break do &#123; if (arr[len].equals(&quot;A&quot;)) &#123; System.out.println(&quot;Array contains &#x27;A&#x27; at index: &quot; + len); // 当找到字母时使用`break`语句中断循环 break; &#125; len++; &#125; while (len &lt; arr.length); &#125;&#125; 执行上面示例代码，得到以下结果： 123Array contains &#x27;I&#x27; at index: 1Array contains &#x27;B&#x27; at index: 3Array contains &#x27;A&#x27; at index: 4 请注意，如果删除break语句，程序的输出将没有任何差异。 对于此示例中的小型迭代，没有的性能问题。 但是如果迭代器次数很大，那么它可以节省大量的处理时间。 示例3. Java break标签break语句标签化用于终止外部循环，应该标记循环以使其起作用。这是一个演示java break标签语句用法的示例。 123456789101112131415161718192021222324252627// package com.yiibai.util;public class JavaBreakLabel &#123; public static void main(String[] args) &#123; int[][] arr = &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125;, &#123; 9, 10 &#125;, &#123; 11, 12 &#125; &#125;; boolean found = false; int row = 0; int col = 0; // 查找第一个大于10的整数所在的索引值 searchint: for (row = 0; row &lt; arr.length; row++) &#123; for (col = 0; col &lt; arr[row].length; col++) &#123; if (arr[row][col] &gt; 10) &#123; found = true; // 使用 break 标签来终止外部语句 break searchint; &#125; &#125; &#125; if (found) System.out.println(&quot;First int greater than 10 is found at index: [&quot; + row + &quot;,&quot; + col + &quot;]&quot;); &#125;&#125; 执行上面示例代码，得到以下结果： 1First int greater than 10 is found at index: [3,0] continue语句Java continue语句用于继续循环。 它继续程序的当前流程，并在指定条件下跳过剩余的代码。在内循环的情况下，它仅继续内循环。 语法： 12jump-statement; continue; Java continue语句示例 12345678910public class ContinueExample &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 10; i++) &#123; if (i == 5) &#123; continue; &#125; System.out.println(i); &#125; &#125;&#125; 执行上面示例代码，得到如下结果 - 1234567891234678910 Java continue语句与内循环 如果在内循环中使用continue语句，它将继续内循环。 示例： 123456789101112public class ContinueExample2 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 3; i++) &#123; for (int j = 1; j &lt;= 3; j++) &#123; if (i == 2 &amp;&amp; j == 2) &#123; continue; &#125; System.out.println(i + &quot; &quot; + j); &#125; &#125; &#125;&#125; 执行上面示例代码，得到如下结果 - 123456781 11 21 32 12 33 13 23 3 Java决策制定Java编程语言提供以下类型的决策制定语句。 可通过单击以下链接来了解和学习。 编号 语句 描述 1 if语句 if语句由布尔表达式后跟一个或多个语句组成。 2 if…else语句 if语句后面可以跟一个可选的else语句，else语句在布尔表达式为false时执行。 3 switch语句 switch语句允许测试变量与值列表的相等性。 if语句if语句由一个布尔表达式后跟一个或多个语句组成。 语法 以下是if语句的语法 - 123if(boolean_expression) &#123; // 如果布尔表达式为`true`，则将执行这里的语句&#125; 如果布尔表达式(boolean_expression)的计算结果为true，那么将执行if语句中的代码块。 如果计算结果为false，将执行if语句结束后(在结束大括号之后)的第一组代码。 示例代码 12345678910111213141516public class IfExample &#123; public static void main(String[] args) &#123; int age = 20; if (age &gt; 18) &#123; System.out.println(&quot;年龄大于 18 岁&quot;); &#125; if (age &lt;= 20) &#123; System.out.println(&quot;年龄小于或等于 20 岁&quot;); &#125; if (age &gt;= 20 &amp;&amp; age &lt; 30) &#123; System.out.println(&quot;年龄小于或等于 20 岁，并且小于 30 岁&quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 123年龄大于 18 岁年龄小于或等于 20 岁年龄小于或等于 20 岁，并且小于 30 岁 if…else语句if语句后面可以跟一个可选的else语句，else语句在布尔表达式为false时执行。 语法 以下是if...else语句的语法 - 12345if(boolean_expression) &#123; // 布尔表达式为true时执行&#125;else &#123; // 布尔表达式为false时执行&#125; 如果布尔表达式的计算结果为true，那么将执行if代码块，否则将执行else代码块。 示例代码 1234567891011121314151617181920212223//一个用于演示if-else语句的Java程序。 public class IfElseExample &#123; public static void main(String[] args) &#123; // 定义一个变量 int number = 133; // 检查数字是否可以被 2 整除？ if (number % 2 == 0) &#123; System.out.println(number + &quot; 是一个偶数&quot;); &#125; else &#123; System.out.println(number + &quot; 是一个奇数&quot;); &#125; // 示例2 int x = 30; if (x &lt; 20) &#123; System.out.println(x + &quot; 是一个小于 20 的整数&quot;); &#125; else &#123; System.out.println(x + &quot; 是一个大于 20 的整数&quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 12133 是一个奇数30 是一个大于 20 的整数 if…else if…else语句if语句之后可以跟一个可选的else if语句，这对于使用if...else if语句测试各种条件非常有用。 当使用if，else if，else语句时，需要记住几点： 一个if语句之后可以有零个或一个else语句，但它必须在else...if之后。 if可以有零或多个else...if，并且它们必须在else语句之前。 当有一个else if条件匹配成功，其余的else...if或者else都将不会执行。 语法 以下是if...else语句的语法 - 123456789if(boolean_expression_1) &#123; // 当 boolean_expression_1 结果为 true 时，执行这里的代码块&#125;else if(boolean_expression_2) &#123; // 当 boolean_expression_2 结果为 true 时，执行这里的代码块&#125;else if(boolean_expression_3) &#123; // 当 boolean_expression_3 结果为 true 时，执行这里的代码块&#125;else &#123; // 当上面表达式都没有一个计算结果为 true 时，执行这里的代码块&#125; 示例代码 123456789101112131415161718192021//Java程序演示如何使用 if else-if 梯形。 //它是一个判断分数级别为：D级，C级，B级，A级和A+级 的程序。public class IfElseIfExample &#123; public static void main(String[] args) &#123; int marks = 65; if (marks &lt; 60) &#123; System.out.println(&quot;D级&quot;); &#125; else if (marks &gt;= 60 &amp;&amp; marks &lt; 70) &#123; System.out.println(&quot;C级&quot;); &#125; else if (marks &gt;= 70 &amp;&amp; marks &lt; 80) &#123; System.out.println(&quot;B级&quot;); &#125; else if (marks &gt;= 80 &amp;&amp; marks &lt; 90) &#123; System.out.println(&quot;A级&quot;); &#125; else if (marks &gt;= 90 &amp;&amp; marks &lt; 100) &#123; System.out.println(&quot;A+级&quot;); &#125; else &#123; System.out.println(&quot;无效!&quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 1C级 switch语句switch语句用于测试变量与值列表的相等性。 每个值称为一个case，并且针对每种情况检查对应的变量值。 语法增强for循环的语法是 - 12345678910111213switch(expression) &#123; case value : // 执行语句块 break; // 可选 case value : // 执行语句块 break; // 可选 // 可以拥有任意数量的 case 语句。 default : // 可选 // 执行语句块&#125; 以下是适用于switch语句的规则 - switch语句中使用的变量只能是整数，可转换为整数(如：byte，short，char)，字符串和枚举类型。 可以在switch中包含任意数量的case语句。每个case后跟要与之比较的值和冒号。 case的值必须与switch中的变量具有相同的数据类型，并且必须是常量或文字。 当switch的变量等于case中的值时，该case之后的语句将一直执行，直到达到break语句。 当达到break语句时switch终止，控制流跳转到switch语句块后面的下一行代码。 不是每个case都需要包含break语句。 如果没有指定break语句，则控制流将落到后续case中，直到达到break语句。 switch语句可以有一个可选的default，它必须出现在switch语句的末尾。 当没有任何case匹配时，执行default中的代码块。default中不需要break语句。 示例1 12345678910111213141516171819202122public class SwitchExample &#123; public static void main(String[] args) &#123; // 为switch表达式声明一个变量 int number = 20; // Switch表达式 switch (number) &#123; // Case语句 case 10: System.out.println(&quot;10&quot;); break; case 20: System.out.println(&quot;20&quot;); break; case 30: System.out.println(&quot;30&quot;); break; // Default case statement default: System.out.println(&quot;Not in 10, 20 or 30&quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 120 示例2 123456789101112131415161718192021222324public class SwitchExample &#123; public static void main(String args[]) &#123; // char grade = args[0].charAt(0); char grade = &#x27;B&#x27;; switch (grade) &#123; case &#x27;A&#x27;: System.out.println(&quot;相当优秀!&quot;); break; case &#x27;B&#x27;: case &#x27;C&#x27;: System.out.println(&quot;一般优秀&quot;); break; case &#x27;D&#x27;: System.out.println(&quot;还不错&quot;); case &#x27;F&#x27;: System.out.println(&quot;好像不太行&quot;); break; default: System.out.println(&quot;无效级别&quot;); &#125; System.out.println(&quot;您的级别是：&quot; + grade); &#125;&#125; 执行上面示例代码，得到以下结果： 12一般优秀您的级别是：B Java方法Java中的方法是一组语句，它们组合在一起以执行各种操作。 例如，当调用System.out.println()方法时，系统实际上会执行多个语句，以便在控制台上显示消息。 下面将学习如何使用或不使用返回值创建自己的方法，使用或不使用参数调用方法，以及在程序设计中应用方法抽象。 创建方法下面来看看方法的语法 - 123public static int methodName(int a, int b) &#123; // body&#125; 在上面语法中， public static − 修辞符 int − 返回值的类型 methodName − 方法的名称 a, b − 形式参数 int a, int b − 参数列表 方法定义由方法头和方法体组成。以下语法中显示了相同的内容 - 123modifier returnType nameOfMethod (Parameter List) &#123; // method body&#125; 上面显示的语法包括 - modifier - 它定义方法的访问类型，它可能是：public,private,protected或不指定。 returnType - 方法可以返回一个值。 nameOfMethod - 这是方法名称，方法签名由方法名称和参数列表组成。 Parameter List - 参数列表，它是方法的类型，顺序和参数数量。 这些是可选的，方法可能包含零参数。 method body - 方法体定义方法对语句的作用。 示例 以下代码中定义了min()方法。 这个方法有两个int类型的参数：num1和num2，并返回两者之间的最大值 - 12345678910/** 返回两个数字之间的最小值 */public static int minFunction(int n1, int n2) &#123; int min; if (n1 &gt; n2) min = n2; else min = n1; return min; &#125; 方法调用可通过调用方法来使用方法，调用方法有两种方式，即方法有返回值或无返回任何值。 方法调用的过程很简单。 当程序调用方法时，程序控制将转移到被调用的方法。 这个被调用的方法然后在两个条件下将控制权返回给调用者，即 - return语句被执行。 它到达方法的结束，即右大括号(&#125;)。 对返回void的方法的调用 - 1System.out.println(&quot;This is Yiibai.com!&quot;); 对有返回值的方法的调用 - 1int result = sum(6, 9); 以下是演示如何定义方法以及如何调用方法的示例 - 1234567891011121314151617181920public class ExampleMinNumber &#123; public static void main(String[] args) &#123; int a = 111; int b = 125; int c = getMin(a, b); System.out.println(&quot;最小值 = &quot; + c); &#125; /** 返回两个 int 数值的最小值 */ public static int getMin(int n1, int n2) &#123; int min; if (n1 &gt; n2) min = n2; else min = n1; return min; &#125;&#125; 执行上面示例代码，得到以下结果： 1最小值 = 111 void关键字void关键字允许创建不返回值的方法。在下面的例子中有一个返回值是void的方法methodRankPoints，它不返回任何值。 调用void方法必须是一个语句，即methodRankPoints(245.67);. 它是一个以分号结尾的Java语句，如以下示例所示 - 12345678910111213141516public class ExampleVoid &#123; public static void main(String[] args) &#123; methodRankPoints(245.67); &#125; public static void methodRankPoints(double points) &#123; if (points &gt;= 202.5) &#123; System.out.println(&quot;Rank:A1&quot;); &#125;else if (points &gt;= 122.4) &#123; System.out.println(&quot;Rank:A2&quot;); &#125;else &#123; System.out.println(&quot;Rank:A3&quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 1Rank:A1 按值传递参数在按值传递参数时需要传递参数。它们的顺序应与方法规范中的参数顺序相同。参数可以通过值或引用传递。 通过值传递参数是使用参数调用方法。 通过这样将参数值将传递给参数。 示例 以下程序显示了按值传递参数的示例。 即使在方法调用之后，参数的值仍保持不变。 12345678910111213141516171819202122public class swappingExample &#123; public static void main(String[] args) &#123; int a = 30; int b = 45; System.out.println(&quot;Before swapping, a = &quot; + a + &quot; and b = &quot; + b); // 调用交换方法 swapFunction(a, b); System.out.println(&quot;Now, Before and After swapping values will be same here:&quot;); System.out.println(&quot;After swapping, a = &quot; + a + &quot; and b is &quot; + b); &#125; public static void swapFunction(int a, int b) &#123; System.out.println(&quot;Before swapping(Inside), a = &quot; + a + &quot; b = &quot; + b); // 交换 n1 和 n2 int c = a; a = b; b = c; System.out.println(&quot;After swapping(Inside), a = &quot; + a + &quot; b = &quot; + b); &#125;&#125; 执行上面示例代码，得到以下结果： 12345Before swapping, a = 30 and b = 45Before swapping(Inside), a = 30 b = 45After swapping(Inside), a = 45 b = 30Now, Before and After swapping values will be same here:After swapping, a = 30 and b is 45 方法重载当一个类有两个或多个同名但方法不同参数的方法时，称为方法重载。 它与重写不同。 在重写中，方法具有相同的方法名称，类型，参数数量等。 在前面讨论的用于查找最小整数类型数的示例中，假设想要查找两个double类型的最小数值。 可引入重载的概念以创建具有相同名称但不同参数的两个或更多方法。 参考以下示例代码 - 12345678910111213141516171819202122232425262728293031323334353637public class ExampleOverloading &#123; public static void main(String[] args) &#123; int a = 11; int b = 6; double c = 7.3; double d = 9.4; int result1 = getMin(a, b); // 具有相同函数名称，但数字不同参数 double result2 = getMin(c, d); System.out.println(&quot;Minimum Value = &quot; + result1); System.out.println(&quot;Minimum Value = &quot; + result2); &#125; // 处理 int 类型的数值(方法重载) public static int getMin(int n1, int n2) &#123; int min; if (n1 &gt; n2) min = n2; else min = n1; return min; &#125; // 处理 double 类型的数值(方法重载) public static double getMin(double n1, double n2) &#123; double min; if (n1 &gt; n2) min = n2; else min = n1; return min; &#125;&#125; 执行上面示例代码，得到以下结果： 12Minimum Value = 6Minimum Value = 7.3 重载方法使程序可读。这里，两个方法由相同的名称给出但具有不同的参数类型。结果是求int类型和double类型的最小数。 使用命令行参数有时希望在运行程序时将一些信息传递给程序。它是通过将命令行参数传递给main()来实现的。 命令行参数是执行时在命令行上直接跟随程序名称的信息。 要访问Java程序中的命令行参数非常简单。 它们作为字符串存储在传递给main()的String类型数组中。 示例 以下程序显示传递给程序的所有命令行参数 - 12345678public class CommandLine &#123; public static void main(String args[]) &#123; for(int i = 0; i&lt;args.length; i++) &#123; System.out.println(&quot;args[&quot; + i + &quot;]: &quot; + args[i]); &#125; &#125;&#125; 使用以下方式执行此程序 - 1java CommandLine this is a command line 200 -100 那么将得到以下结果： 1234567args[0]: thisargs[1]: isargs[2]: aargs[3]: commandargs[4]: lineargs[5]: 200args[6]: -100 this关键字this是Java中的一个关键字，用作对当前类对象的引用，在实例方法或构造函数中。 使用它可以引用类的成员，例如：构造函数，变量和方法。 注 - this关键字仅在实例方法或构造函数中使用。 通常，this关键字用于 - 如果实例变量在构造函数或方法中具有相同的名称，则将它们与局部变量区分开来。 123456class Student &#123; private int age; Student(int age) &#123; this.age = age; &#125;&#125; 从类中的其他方法调用一种类型的构造函数(参数化构造函数或默认值)，称为显式构造函数调用。 123456789class Student &#123; int age; Student() &#123; this(20); &#125; Student(int age) &#123; this.age = age; &#125;&#125; 以下是使用this关键字访问类成员的示例 - 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ThisExample &#123; // 实例变量：num int num = 10; ThisExample() &#123; System.out.println(&quot;This is an example program on keyword this&quot;); &#125; ThisExample(int num) &#123; // 调用默认构造方法 this(); // 将局部变量 num 分配给实例变量 num this.num = num; &#125; public void greet() &#123; System.out.println(&quot;Hi Welcome to Yiibai&quot;); &#125; public void print() &#123; // 局部变量：num int num = 20; // 打印局部变量 System.out.println(&quot;value of local variable num is : &quot;+num); // 打印实例变量 System.out.println(&quot;value of instance variable num is : &quot;+this.num); // 调用类方法 this.greet(); &#125; public static void main(String[] args) &#123; // 实例化该类 ThisExample obj1 = new ThisExample(); // 调用 print 方法 obj1.print(); //通过参数化构造函数将新值传递给 num 变量 ThisExample obj2 = new ThisExample(30); // 再次调用 print 方法 obj2.print(); &#125;&#125; 执行上面示例代码，得到以下结果 - 12345678This is an example program on keyword this value of local variable num is : 20value of instance variable num is : 10Hi Welcome to YiibaiThis is an example program on keyword this value of local variable num is : 20value of instance variable num is : 30Hi Welcome to Yiibai 变量参数(var-args)JDK 1.5允许将可变数量的相同类型的参数传递给方法。方法中的参数声明如下 - 1typeName... parameterName 在方法声明中，指定类型后跟省略号(...)。 在方法中只能指定一个可变长度参数，并且此参数必须是最后一个参数。 12345678910111213141516171819202122public class VarargsDemo &#123; public static void main(String args[]) &#123; // 使用变量参数调用方法 printMax(314, 321, 213, 212, 356.5); printMax(new double[]&#123;1, 2, 3&#125;); &#125; public static void printMax( double... numbers) &#123; if (numbers.length == 0) &#123; System.out.println(&quot;No argument passed&quot;); return; &#125; double result = numbers[0]; for (int i = 1; i &lt; numbers.length; i++) if (numbers[i] &gt; result) result = numbers[i]; System.out.println(&quot;参数列表中的最大值是：&quot; + result); &#125;&#125; 执行上面示例代码，得到以下结果 - 12参数列表中的最大值是：356.5参数列表中的最大值是：3.0 finalize()方法finalize()方法在垃圾收集器对象最终销毁之前调用，它可用于确保对象完全终止。例如，可以使用finalize()来确保该对象拥有的打开文件已关闭。 要将终结器添加到类中，只需定义finalize()方法即可。只要Java方法要回收该类的对象，它就会调用该方法。 在finalize()方法中，将指定在销毁对象之前必须执行的操作。finalize()方法有这种一般形式 - 123protected void finalize( ) &#123; // finalization code here&#125; 这里，关键字protected是一个修辞符，它阻止通过类外部定义的代码访问finalize()。我们无法知道Java何时或甚至是否将执行finalize()方法。如果程序在垃圾收集发生之前结束，则finalize()将不会执行。 Java正则表达式Java提供了java.util.regex包，用于与正则表达式进行模式匹配。 Java正则表达式与Perl编程语言非常相似，非常容易学习。 正则表达式是一种特殊的字符序列，可使用模式中的专用语法来匹配或查找其他字符串或字符串集。 它们可用于搜索，编辑或操作文本和数据。 java.util.regex包主要由以下三个类组成 - Pattern类 - Pattern对象是正则表达式的编译表示。 Pattern类不提供公共构造函数。 要创建模式，需要首先调用它的公共静态compile()方法，然后返回Pattern对象。 这些方法接受正则表达式作为第一个参数。 Matcher类 - Matcher对象是解释模式并对输入字符串执行匹配操作的引擎。 与Pattern类一样，Matcher没有定义公共构造函数。 通过在Pattern对象上调用matcher()方法获取Matcher对象。 PatternSyntaxException - PatternSyntaxException对象是未经检查的异常，指示正则表达式模式中的语法错误。 捕获组捕获组是将多个字符视为一个单元的一种方法。 它们是通过将要分组的字符放在一组括号中来创建的。 例如，正则表达式(dog)创建包含字母d，o和g的单个组。 捕获组通过从左到右计算它们的左括号来编号。 在表达式((A)(B(C)))中，例如，有四个这样的组 - ((A)(B(C))) (A) (B(C)) (C) 要查找表达式中存在多少个组，请在Matcher对象上调用groupCount()方法。 groupCount()方法返回一个int类型值，显示Matcher模式中存在的捕获组数。 还有一个特殊组，即组0，它始终代表整个表达式。 该组未包含在groupCount()报告的总数中。 示例 以下示例说明如何从给定的字母数字字符串中查找数字字符串 - 123456789101112131415161718192021222324import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches &#123; public static void main( String args[] ) &#123; // String to be scanned to find the pattern. String line = &quot;This order was placed for QT3000! OK?&quot;; String pattern = &quot;(.*)(\\\\d+)(.*)&quot;; // Create a Pattern object Pattern r = Pattern.compile(pattern); // Now create matcher object. Matcher m = r.matcher(line); if (m.find( )) &#123; System.out.println(&quot;Found value: &quot; + m.group(0) ); System.out.println(&quot;Found value: &quot; + m.group(1) ); System.out.println(&quot;Found value: &quot; + m.group(2) ); &#125;else &#123; System.out.println(&quot;NO MATCH&quot;); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 123Found value: This order was placed for QT3000! OK?Found value: This order was placed for QT300Found value: 0 正则表达式语法下面列出了Java中可用的所有正则表达式元字符语法 - 编号 子表达式 匹配 1 ^ 匹配行的开头。 2 $ 匹配行的结尾。 3 . 匹配除换行符之外的任何单个字符，使用m选项也可以匹配换行符。 4 [...] 匹配括号中的任何单个字符。 5 [^...] 匹配括号内的任何单个字符。 6 \\A 整个字符串的开头。 7 \\z 整个字符串的结尾。 8 \\Z 除允许的最终行终止符之外的整个字符串的结尾。 9 re* 匹配前面表达式的0次或更多次出现。 10 re+ 匹配前面表达式的1次或更多次出现。 11 re? 匹配前面表达式的0或1次出现。 12 re&#123;n&#125; 准确匹配前面表达式的n次出现次数。 13 re&#123;n,&#125; 准确匹配前面表达式的n次以上出现次数。 14 aΙb 匹配a或b。 15 (re) 对正则表达式进行分组并记住匹配的文本。 16 (?: re) 将正则表达式分组而不记住匹配的文本。 17 (?&gt; re) 匹配独立模式而无需回溯。 18 \\w 匹配单词字符。 19 \\W 匹配非单词字符。 20 \\s 匹配空白符，相当于：[\\t\\n\\r\\f] 21 \\S 匹配非空白。 22 \\d 匹配数字，相当于：[0-9]。 23 \\D 匹配非数字。 24 \\A 匹配字符串的开头。 25 \\Z 匹配字符串的结尾。如果存在换行符，则它在换行符之前匹配。 26 \\z 匹配字符串的结尾。 27 \\G 匹配最后一个匹配结束的点。 28 \\n 反向引用以捕获组号：n。 29 \\b 在括号外部匹配单词边界，在括号内匹配退格(0x08)。 30 \\B 匹配非字边界。 31 \\n,\\t 匹配换行符，回车符，制表符等。 32 \\E 转义(引用)所有字符直到\\E。 33 \\Q 结束以\\Q开头引用。 start()和end()方法 以下是计算字符串中：cat一词的出现次数示例 - 123456789101112131415161718192021import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches &#123; private static final String REGEX = &quot;\\\\bcat\\\\b&quot;; private static final String INPUT = &quot;cat cat cat cattie cat&quot;; public static void main( String args[] ) &#123; Pattern p = Pattern.compile(REGEX); Matcher m = p.matcher(INPUT); // get a matcher object int count = 0; while(m.find()) &#123; count++; System.out.println(&quot;Match number &quot;+count); System.out.println(&quot;start(): &quot;+m.start()); System.out.println(&quot;end(): &quot;+m.end()); &#125; &#125;&#125; 执行上面示例代码，得到以下结果： 123456789101112Match number 1start(): 0end(): 3Match number 2start(): 4end(): 7Match number 3start(): 8end(): 11Match number 4start(): 19end(): 22 可以看到此示例使用单词边界来确保字母：c,a,t不仅仅是较长单词中的子字符串。 它还提供了有关输入字符串中匹配发生位置的一些有用信息。 start方法返回上一个匹配操作期间给定组捕获的子序列的起始索引，end返回匹配的最后一个字符的索引加1。 matches和lookingAt方法 matches()和lookingAt()方法都尝试将输入序列与模式匹配。 然而，不同之处在于匹配需要匹配整个输入序列，而查找则不需要。 两种方法总是从输入字符串的开头开始。 以下是上述方法的示例 - 123456789101112131415161718192021import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches &#123; private static final String REGEX = &quot;foo&quot;; private static final String INPUT = &quot;fooooooooooooooooo&quot;; private static Pattern pattern; private static Matcher matcher; public static void main( String args[] ) &#123; pattern = Pattern.compile(REGEX); matcher = pattern.matcher(INPUT); System.out.println(&quot;Current REGEX is: &quot;+REGEX); System.out.println(&quot;Current INPUT is: &quot;+INPUT); System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt()); System.out.println(&quot;matches(): &quot;+matcher.matches()); &#125;&#125; 执行上面示例代码，得到以下结果： 1234Current REGEX is: fooCurrent INPUT is: fooooooooooooooooolookingAt(): truematches(): false replaceFirst和replaceAll方法replaceFirst()和replaceAll()方法替换匹配给定正则表达式的文本。 正如其名称所示，replaceFirst()替换第一个匹配项，replaceAll()替换所有匹配项。 以下是上述功能的示例 - 123456789101112131415161718import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches &#123; private static String REGEX = &quot;dog&quot;; private static String INPUT = &quot;The dog says meow. &quot; + &quot;All dogs say meow.&quot;; private static String REPLACE = &quot;cat&quot;; public static void main(String[] args) &#123; Pattern p = Pattern.compile(REGEX); // get a matcher object Matcher m = p.matcher(INPUT); INPUT = m.replaceAll(REPLACE); System.out.println(INPUT); &#125;&#125; 执行上面示例代码，得到以下结果： 1The cat says meow. All cats say meow. appendReplacement和appendTail方法 Matcher类还提供了appendReplacement和appendTail方法来替换文本。 以下是上述方法的示例 - 12345678910111213141516171819202122import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches &#123; private static String REGEX = &quot;a*b&quot;; private static String INPUT = &quot;aabfooaabfooabfoob&quot;; private static String REPLACE = &quot;-&quot;; public static void main(String[] args) &#123; Pattern p = Pattern.compile(REGEX); // get a matcher object Matcher m = p.matcher(INPUT); StringBuffer sb = new StringBuffer(); while(m.find()) &#123; m.appendReplacement(sb, REPLACE); &#125; m.appendTail(sb); System.out.println(sb.toString()); &#125;&#125; 执行上面示例代码，得到以下结果： 1-foo-foo-foo-","categories":[{"name":"语言","slug":"语言","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"}]},{"title":"励志成为IDEA高手","slug":"工具/IDEA/励志成为IDEA高手","date":"2024-04-18T10:23:54.000Z","updated":"2024-08-21T02:10:23.835Z","comments":true,"path":"2024/04/18/工具/IDEA/励志成为IDEA高手/","link":"","permalink":"https://azoker.top/2024/04/18/%E5%B7%A5%E5%85%B7/IDEA/%E5%8A%B1%E5%BF%97%E6%88%90%E4%B8%BAIDEA%E9%AB%98%E6%89%8B/","excerpt":"本文总结我遇到IDEA不听使唤的所有问题。","text":"target目录不显示如果你已经构建了项目但是并没有出现target目录，可以查看是否开启了显示。 gitlab提示需要token报错情况 解决方法 解决方法就是禁用gitlab插件 效果如下","categories":[{"name":"工具","slug":"工具","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"IDEA","slug":"工具/IDEA","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://azoker.top/tags/IDEA/"}]},{"title":"在项目中集成Swagger生成接口文档","slug":"代码/入门案例/在项目中集成Swagger生成接口文档","date":"2024-04-05T00:23:54.000Z","updated":"2024-08-28T03:06:50.655Z","comments":true,"path":"2024/04/05/代码/入门案例/在项目中集成Swagger生成接口文档/","link":"","permalink":"https://azoker.top/2024/04/05/%E4%BB%A3%E7%A0%81/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Swagger%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/","excerpt":"swagger对于后端开发来说绝对是一大利器。","text":"依赖123456789101112131415161718&lt;!--swagger--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--swagger-ui的jar包(里面包含了swagger的界面静态文件) --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--knife4j--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-ui&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt; 配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.ApiKey;import springfox.documentation.service.AuthorizationScope;import springfox.documentation.service.SecurityReference;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spi.service.contexts.SecurityContext;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;import java.util.List;@EnableSwagger2@Configurationpublic class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .pathMapping(&quot;/&quot;) .select() .apis(RequestHandlerSelectors.basePackage(&quot;包路径！！！&quot;)) .paths(PathSelectors.any()) .build().apiInfo(apiInfo()) .securitySchemes(securitySchemes()) .securityContexts(securityContexts()); &#125; private List&lt;ApiKey&gt; securitySchemes() &#123; List&lt;ApiKey&gt; apiKeyList = new ArrayList(); apiKeyList.add(new ApiKey(&quot;token&quot;, &quot;token&quot;, &quot;header&quot;)); return apiKeyList; &#125; private List&lt;SecurityContext&gt; securityContexts() &#123; List&lt;SecurityContext&gt; securityContexts = new ArrayList&lt;&gt;(); securityContexts.add(SecurityContext.builder().securityReferences(defaultAuth()) .forPaths(PathSelectors.regex(&quot;^(?!auth).*$&quot;))//过滤要验证的路径 .build()); return securityContexts; &#125; //增加全局认证 List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; List&lt;SecurityReference&gt; securityReferences = new ArrayList&lt;&gt;(); securityReferences.add(new SecurityReference(&quot;token&quot;, authorizationScopes));//验证增加（有许多教程说明中这个地方是Authorization,导致不能带入全局token，因为securitySchemes()方法中header写入token，所以这个地方我改为token就可以了） return securityReferences; &#125; /** * 接口文档信息 * * @return */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;标题&quot;) .description(&quot;描述&quot;) .version(&quot;1.0.0&quot;) .termsOfServiceUrl(&quot;&quot;) .license(&quot;&quot;) .licenseUrl(&quot;&quot;) .build(); &#125;&#125; 使用方法1234567891011@RequestMapping(&quot;/user&quot;)@RestController@Api(tags = &quot;用户相关接口&quot;)public class UserController &#123; @PostMapping(value = &quot;/list&quot;) @ApiOperation(value = &quot;查询列表&quot;,httpMethod = &quot;POST&quot;) public String list() &#123; return &quot;success&quot;; &#125;&#125; 访问地址 &#x2F;swagger-ui&#x2F;index.html &#x2F;doc.html","categories":[{"name":"代码","slug":"代码","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/"},{"name":"入门案例","slug":"代码/入门案例","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://azoker.top/tags/Mybatis/"}]},{"title":"在项目中集成POI并导入导出Excel表","slug":"代码/入门案例/在项目中集成POI并导入导出Excel表","date":"2024-04-04T10:23:54.000Z","updated":"2024-08-28T03:06:35.322Z","comments":true,"path":"2024/04/04/代码/入门案例/在项目中集成POI并导入导出Excel表/","link":"","permalink":"https://azoker.top/2024/04/04/%E4%BB%A3%E7%A0%81/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90POI%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BAExcel%E8%A1%A8/","excerpt":"POI入门非常简单，不过仍需要注意一些地方。","text":"导入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt;&lt;/dependency&gt; 简单导出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileOutputStream;public class PoiTest &#123; public static void main(String[] args) throws Exception &#123; write(); &#125; /** * 通过poi创建一个excel文件，并写入数据 */ public static void write() throws Exception &#123; //在内存中，创建一个excel文件 XSSFWorkbook excel = new XSSFWorkbook(); //在excel文件中创建sheet页 XSSFSheet sheet = excel.createSheet(&quot;第一页&quot;); //在sheet页中创建行，rownum编号从0开始 XSSFRow row = sheet.createRow(0); //创建单元格，并将数据写入单元格 row.createCell(0).setCellValue(&quot;姓名&quot;); row.createCell(1).setCellValue(&quot;城市&quot;); //创建新行 row = sheet.createRow(1); row.createCell(0).setCellValue(&quot;张三&quot;); row.createCell(1).setCellValue(&quot;北京&quot;); //再创建新行 row = sheet.createRow(2); row.createCell(0).setCellValue(&quot;李四&quot;); row.createCell(1).setCellValue(&quot;南京&quot;); //创建输出流对象，将内存中的excel写入到磁盘 FileOutputStream outputStream = new FileOutputStream(new File(&quot;D:\\\\info.xlsx&quot;)); excel.write(outputStream); //关闭资源 outputStream.close(); excel.close(); &#125;&#125; 可以看到下面这张图： 需要说明的是，如果单元格存在数据，那么会直接覆盖掉。 简单导入123456789101112131415161718192021222324252627282930public static void read() throws Exception &#123; //获取输入流对象 FileInputStream fileInputStream = new FileInputStream(new File(&quot;D:\\\\info.xlsx&quot;)); //创建excel对象，读取excel文件 XSSFWorkbook excel = new XSSFWorkbook(fileInputStream); //读取excel文件中第一个sheet页 XSSFSheet sheetAt = excel.getSheetAt(0); //获取excel中数据最后一行的行号 int lastRowNum = sheetAt.getLastRowNum(); //从第二行开始读 for (int i = 1; i &lt;= lastRowNum; i++) &#123; //获得某一行数据 XSSFRow row = sheetAt.getRow(i); //获得第二个单元格对象 String cellValue1 = row.getCell(0).getStringCellValue(); //获得第三个单元格对象 String cellValue2 = row.getCell(1).getStringCellValue(); //打印数据 System.out.println(cellValue1 + &quot; &quot; + cellValue2); &#125; //关闭资源 fileInputStream.close(); excel.close();&#125; 注意一点，每一个单元格的数据类型是String","categories":[{"name":"代码","slug":"代码","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/"},{"name":"入门案例","slug":"代码/入门案例","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"POI","slug":"POI","permalink":"https://azoker.top/tags/POI/"}]},{"title":"在项目中集成MybatisFlex并测试增删改查","slug":"代码/入门案例/在项目中集成MybatisFlex并测试增删改查","date":"2024-04-04T10:23:54.000Z","updated":"2024-09-12T05:55:14.193Z","comments":true,"path":"2024/04/04/代码/入门案例/在项目中集成MybatisFlex并测试增删改查/","link":"","permalink":"https://azoker.top/2024/04/04/%E4%BB%A3%E7%A0%81/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90MybatisFlex%E5%B9%B6%E6%B5%8B%E8%AF%95%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"我现在测试的是单表的增删改查，只能说算是入门，可以复制粘贴代码了解一下流程，更加复杂的操作其实官网已经非常详细，但是仍有一些地方需要注意。","text":"环境准备导入依赖12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mybatis-flex&lt;/groupId&gt; &lt;artifactId&gt;mybatis-flex-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mybatis-flex&lt;/groupId&gt; &lt;artifactId&gt;mybatis-flex-processor&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;4.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这些依赖分别是Web、Flex、MySQL、数据库连接池、Lombok、单元测试。 数据库文件12345678CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `nickname` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT &#x27;昵称&#x27;, `username` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT &#x27;用户名&#x27;, `password` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT &#x27;密码&#x27;, `is_deleted` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 0-未删除 1-删除&#x27;, PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#x27;用户表&#x27;; MVC架构1234567891011121314151617181920212223242526272829303132333435363738394041424344/*实体类*/import com.mybatisflex.annotation.*;import lombok.Data;import java.io.Serializable;@Data@Table(&quot;user&quot;)public class User implements Serializable &#123; @Id(keyType = KeyType.Auto) private int id; private String username; private String password; private String nickname; @Column(isLogicDelete = true) private Integer isDeleted; @Column(ignore = true) @RelationOneToOne( selfField = &quot;id&quot;, targetField = &quot;userId&quot;, targetTable = &quot;id_card&quot;) private IDCard idCard;&#125;/*DAO层*/import com.azoker.pojo.User;import com.mybatisflex.core.BaseMapper;import org.springframework.stereotype.Repository;@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;/*启动器*/import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.azoker.mapper&quot;)public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 类似于MybatisPlus，所以我就不展示太多业务层的代码，而且测试是在单元测试。就需要注意两个点： DAO层继承BaseMapper 启动类扫描mapper接口 测试代码编写测试类，注意包路径。然后的话我现在测试的是单表的增删改查，只能说算是入门，可以复制粘贴代码了解一下流程，更加复杂的操作其实官网已经非常详细，但是仍有一些地方需要注意。我会再写一篇博客，届时具体说明。 1234567891011121314package com.azoker;import com.azoker.mapper.UserMapper;import com.azoker.pojo.User;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;@SpringBootTestpublic class UserCurdTest &#123; @Autowired private UserMapper userMapper;&#125; 新增数据1234567891011121314151617181920212223242526/** * 新增一条数据 */@Testpublic void add() &#123; User user = new User(); user.setUsername(&quot;test&quot;); user.setPassword(&quot;123456&quot;); user.setNickname(&quot;test&quot;); userMapper.insert(user);&#125;/** * 批量新增数据 */@Testpublic void batchAdd() &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(); user.setUsername(&quot;test&quot; + i); user.setPassword(&quot;654321&quot;); user.setNickname(&quot;test&quot; + i); users.add(user); &#125; System.out.println(userMapper.insertBatch(users, 10)); // 返回受影响的行数&#125; 查询所有数据12345678@Testpublic void selectAll() &#123; List&lt;User&gt; users = userMapper.selectAll(); users.forEach(System.out::println); // 相当于 // users.forEach(user -&gt; System.out.println(user));&#125; 分页查询带条件分页的做法太多太多了，这里用的是Flex很简单的写法。 123456789101112@Testpublic void page() &#123; Integer id = 1; //可以试试null模拟传空参 int pageNum = 1; //当前页码, 也可以是 Integer 类型 int pageSize = 5; //每页显示条数, 也可以是 Integer 类型 QueryWrapper query = new QueryWrapper(); query.where(USER.ID.gt(id)); // 等同于 // query.where(&quot;id &gt; ?&quot;, id); Page&lt;User&gt; users = userMapper.paginate(pageNum, pageSize, query); users.getRecords().forEach(System.out::println);&#125; 这里我需要提一下这个： 12QueryWrapper query = new QueryWrapper();query.where(USER.ID.gt(id)); 这个USER.ID就是表字段，这是Flex自己生成的，类似于Lombok的原理。那么具体怎么做呢？只需要构建项目就好了，一些版本的Flex会自动生成target文件，就想下面这样： 当然有的版本不会，需要手动开启。在项目根目录下新建mybatis-flex.config文件，内容如下：processor.allInTables.enable=true，再去构建项目。 如果不想使用USER.ID，就像下面这样也行： 12QueryWrapper query = new QueryWrapper();query.where(&quot;id &gt; ?&quot;, id); 修改数据(密码)1234567891011@Testpublic void update() &#123; User user = new User(); user.setId(8); user.setUsername(&quot;test&quot;); user.setPassword(&quot;654321&quot;); user.setNickname(&quot;test&quot;); System.out.println(userMapper.update(user)); User users = userMapper.selectOneById(1); System.out.println(users);&#125; 删除数据在实体类里面可以看到有个属性是这样的： 12@Column(isLogicDelete = true)private Integer isDeleted; 有了这个属性，在执行删除操作的时候实际上是执行更新操作，也就是把这个字段的值 0 修改为 1。而并不是执行真的删除操作。 123456789101112131415161718/** * 删除一条数据 */@Testpublic void delete() &#123; System.out.println(userMapper.deleteById(8)); List&lt;User&gt; users = userMapper.selectAll(); users.forEach(System.out::println);&#125;/** * 批量删除 */@Testpublic void batchDelete() &#123; List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3); System.out.println(userMapper.deleteBatchByIds(ids));&#125; 当然如果你不去设置这个逻辑删除标记字段@Column(isLogicDelete = true)那么在执行删除操作的时候就是物理删除了。","categories":[{"name":"代码","slug":"代码","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/"},{"name":"入门案例","slug":"代码/入门案例","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://azoker.top/tags/Mybatis/"}]},{"title":"Please refer to xxxtargetsurefire-reports for theindividual test results","slug":"工具/Maven/Please refer to xxxtargetsurefire-reports for theindividual test results","date":"2024-03-19T10:23:54.000Z","updated":"2024-08-23T05:44:46.180Z","comments":true,"path":"2024/03/19/工具/Maven/Please refer to xxxtargetsurefire-reports for theindividual test results/","link":"","permalink":"https://azoker.top/2024/03/19/%E5%B7%A5%E5%85%B7/Maven/Please%20refer%20to%20xxxtargetsurefire-reports%20for%20theindividual%20test%20results/","excerpt":"报错信息大致是指在构建项目的时候，有测试错误叫你自己去看，实际如果只需要关心打包的话我们就可以跳过测试。","text":"报错信息Please refer to D:\\java\\code\\springboot_web_config\\target\\surefire-reports for the individual test results.Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream. 解决方案 找到 pom.xml 文件 修改 properties 1234&lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;/properties&gt; 原因分析报错信息大致是指在构建项目的时候，有测试错误叫你自己去看，实际如果只需要关心打包的话我们就可以跳过测试，于是就有了上面的解决办法。","categories":[{"name":"工具","slug":"工具","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Maven","slug":"工具/Maven","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://azoker.top/tags/Maven/"}]},{"title":"maven依赖大全","slug":"工具/Maven/Maven依赖大全","date":"2024-03-18T10:23:54.000Z","updated":"2024-08-21T02:21:02.298Z","comments":true,"path":"2024/03/18/工具/Maven/Maven依赖大全/","link":"","permalink":"https://azoker.top/2024/03/18/%E5%B7%A5%E5%85%B7/Maven/Maven%E4%BE%9D%E8%B5%96%E5%A4%A7%E5%85%A8/","excerpt":"在使用 Java 开发项目的时候，我们经常会使用 Jar 包，但是复杂的开发需要引入非常多的 Jar 包，非常多。Maven 就可以帮我们管理这些 Jar 包，而且我们要引入 Jar 就需要引入 Maven 的坐标即可，这些坐标不需要自己写，网上搜索即可。","text":"Maven解释首先我需要解释什么是 Maven 依赖。在使用 Java 开发项目的时候，我们经常会使用 Jar 包，但是复杂的开发需要引入非常多的 Jar 包，非常多。Maven 就可以帮我们管理这些 Jar 包，而且我们要引入 Jar 就需要引入 Maven 的坐标即可，这些坐标不需要自己写，网上搜索即可。Maven 的功能远不止这些，总之自己探索吧。 Web12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; MySQL123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.33&lt;/version&gt;&lt;/dependency&gt;&lt;!--新坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;8.0.33&lt;/version&gt;&lt;/dependency&gt; Swagger123456789101112&lt;!--swagger--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--swagger-ui的jar包(里面包含了swagger的界面静态文件) --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Hutool12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.5&lt;/version&gt;&lt;/dependency&gt; Lombok12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt;&lt;/dependency&gt; SpringBoot项目很有必要解释 SpringBoot 的作用。因为我们导入很多 Jar 包，但是这些 Jar 包并不是直接就能拿来用的，需要我们配置一些信息。这些信息只要是学过 SSM 的都知道非常繁琐，于是 SpringBoot 就诞生了，它能自己去帮我们配置。 Test12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;","categories":[{"name":"工具","slug":"工具","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Maven","slug":"工具/Maven","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://azoker.top/tags/Maven/"}]},{"title":"The alias 'xxx' is already mapped to the value 'com.demo.xxx'","slug":"框架/Mybatis/The alias 'xxx' is already mapped to the value 'com.demo.xxx'","date":"2023-05-20T10:23:54.000Z","updated":"2024-08-21T02:25:27.917Z","comments":true,"path":"2023/05/20/框架/Mybatis/The alias 'xxx' is already mapped to the value 'com.demo.xxx'/","link":"","permalink":"https://azoker.top/2023/05/20/%E6%A1%86%E6%9E%B6/Mybatis/The%20alias%20'xxx'%20is%20already%20mapped%20to%20the%20value%20'com.demo.xxx'/","excerpt":"看到网上说各种冲突的问题，实际上我并没那么复杂的问题，只是因为一个类被我移到了另一个包里，但是依旧提示原来的类已经存在，我清理完缓存就可以继续运行了，如果我的方案不行，请查阅其他博客。","text":"报错信息12345678Caused by: org.apache.ibatis.type.TypeException: The alias &#x27;xxx&#x27; is already mapped to the value &#x27;com.demo.xxx&#x27;. at org.apache.ibatis.type.TypeAliasRegistry.registerAlias(TypeAliasRegistry.java:151) at org.apache.ibatis.type.TypeAliasRegistry.registerAlias(TypeAliasRegistry.java:144) at org.apache.ibatis.type.TypeAliasRegistry.registerAliases(TypeAliasRegistry.java:133) at org.apache.ibatis.type.TypeAliasRegistry.registerAliases(TypeAliasRegistry.java:122) at org.apache.ibatis.builder.xml.XMLConfigBuilder.typeAliasesElement(XMLConfigBuilder.java:118) at org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XMLConfigBuilder.java:99) ... 64 more 解决方法看到网上说各种冲突的问题，实际上我并没那么复杂的问题，只是因为一个类被我移到了另一个包里，但是依旧提示原来的类已经存在，我清理完缓存就可以继续运行了，如果我的方案不行，请查阅其他博客。 思考其实在这段报错的上级报错是说sqlsession创建错误，想到sqlsession的话，可以去思考一下Mybatis的一二级缓存。然后的话我猜想，我的类原本已经查出来了，放到了二级缓存里面，二级缓存不同的sqlsession是共享的，于是会存在包名的冲突。在创建sqlsession的时候查询二级缓存，结果缓存的包名不对，自然就创建错误了。","categories":[{"name":"框架","slug":"框架","permalink":"https://azoker.top/categories/%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"框架/Mybatis","permalink":"https://azoker.top/categories/%E6%A1%86%E6%9E%B6/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://azoker.top/tags/Mybatis/"}]},{"title":"代理模式","slug":"语言/设计模式/代理模式","date":"2023-03-18T10:23:54.000Z","updated":"2024-08-23T03:40:07.861Z","comments":true,"path":"2023/03/18/语言/设计模式/代理模式/","link":"","permalink":"https://azoker.top/2023/03/18/%E8%AF%AD%E8%A8%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过**代理对象**访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。","text":"参考文章：https://mp.weixin.qq.com/s/GT1-yrxJ5KF0xeMydbJDCQ 如果要理解代理模式请先了解以下的知识点，知道概念即可： 接口 JVM 代理模式概念代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。是不是和AOP思想非常类似？小伙伴们可以先记个结论，Spring AOP底层就是通过动态代理实现的。 代理模式分类刚刚提到了动态代理，其实还有静态代理： 静态代理：在编译时就已经实现，编译完成后代理类是一个实际的class文件。 动态代理：在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中。其实也非常好理解，静态代理就是在编译的时候就已经生成代理对象的字节码文件了；而动态代理是在运行的时候才去生成字节码文件。 静态代理先说静态代理，当然我也只是简单举个例子：① 简单的接口和实现类 1234567891011// 接口public interface UserDao &#123; void save();&#125;// 实现类public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;正在保存用户...&quot;); &#125;&#125; ② 代理对象类 1234567891011121314151617public class TransactionHandler implements UserDao &#123; //目标代理对象 private UserDao target; //构造代理对象时传入目标对象 public TransactionHandler(UserDao target) &#123; this.target = target; &#125; @Override public void save() &#123; //调用目标方法前的处理 System.out.println(&quot;开启事务控制...&quot;); //调用目标对象的方法 target.save(); //调用目标方法后的处理 System.out.println(&quot;关闭事务控制...&quot;); &#125;&#125; ③ 具体使用代理对象类 12345678910public class Main &#123; public static void main(String[] args) &#123; //新建目标对象 UserDaoImpl target = new UserDaoImpl(); //创建代理对象, 并使用接口对其进行引用 UserDao userDao = new TransactionHandler(target); //针对接口进行调用 userDao.save(); &#125;&#125; 显而易见的是，静态代理需要给被代理的对象编写一个代理类，代码冗余不说，而且灵活性也很差。因此就有了动态代理这种方式，而且我们所接触到的代理模式基本上都是指动态代理。 动态代理我们的八股文这样说，实现了接口的走JDK动态代理，没有实现接口的走CGLib动态代理。具体是怎么样呢？下面我会详细说说。 JDK 动态代理使用JDK动态代理的五大步骤： 通过实现InvocationHandler接口来自定义自己的InvocationHandler； 通过Proxy.getProxyClass获得动态代理类； 通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)； 通过构造函数获得代理对象并将自定义的InvocationHandler实例对象传为参数传入； 通过代理对象调用目标方法； 1234567891011//接口public interface IHello &#123; void sayHello();&#125;//实现类public class HelloImpl implements IHello &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello world!&quot;); &#125;&#125; 123456789101112131415161718192021import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method; public class MyInvocationHandler implements InvocationHandler &#123; /** 目标对象 */ private Object target; public MyInvocationHandler(Object target)&#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;------插入前置通知代码-------------&quot;); // 执行相应的目标方法 Object rs = method.invoke(target,args); System.out.println(&quot;------插入后置处理代码-------------&quot;); return rs; &#125;&#125; 12345678910111213141516171819202122232425262728293031import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;public class MyProxyTest &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; // =========================第一种========================== // 1、生成$Proxy0的class文件 System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;); // 2、获取动态代理类 Class proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(),IHello.class); // 3、获得代理类的构造函数，并传入参数类型InvocationHandler.class Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class); // 4、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入 IHello iHello1 = (IHello) constructor.newInstance(new MyInvocationHandler(new HelloImpl())); // 5、通过代理对象调用目标方法 iHello1.sayHello(); // ==========================第二种============================= /** * Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象， *其方法签名为：newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] instance, InvocationHandler h) */ IHello iHello2 = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), // 加载接口的类加载器 new Class[]&#123;IHello.class&#125;, // 一组接口 new MyInvocationHandler(new HelloImpl())); // 自定义的InvocationHandler iHello2.sayHello(); &#125;&#125; 看不懂也没关系，因为动态代理经常由框架本身设计好，可以先浅浅了解。JDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。 不同之处： 在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。 一句话来总结一下JDK静态代理和JDK动态代理的区别： JDK静态代理是通过直接编码创建的，而JDK动态代理是利用反射机制在运行时创建代理类的。 其实在动态代理中，核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的invoke方法 对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。 CGLIB 动态代理 CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类 CGLIB代理实现如下： 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。 然后在需要使用的时候，通过CGLIB动态代理获取代理对象。 123456789101112131415161718public class HelloService &#123; public HelloService() &#123; System.out.println(&quot;HelloService构造&quot;); &#125; /** * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的 */ final public String sayOthers(String name) &#123; System.out.println(&quot;HelloService:sayOthers&gt;&gt;&quot;+name); return null; &#125; public void sayHello() &#123; System.out.println(&quot;HelloService:sayHello&quot;); &#125;&#125; 123456789101112131415161718192021222324import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; /** * 自定义MethodInterceptor */public class MyMethodInterceptor implements MethodInterceptor&#123; /** * sub：cglib生成的代理对象 * method：被代理对象方法 * objects：方法入参 * methodProxy: 代理方法 */ @Override public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;======插入前置通知======&quot;); Object object = methodProxy.invokeSuper(sub, objects); System.out.println(&quot;======插入后者通知======&quot;); return object; &#125;&#125; 12345678910111213141516171819import net.sf.cglib.core.DebuggingClassWriter;import net.sf.cglib.proxy.Enhancer; public class Client &#123; public static void main(String[] args) &#123; // 代理类class文件存入本地磁盘方便我们反编译查看源码 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:\\\\code&quot;); // 通过CGLIB动态代理获取代理对象的过程 Enhancer enhancer = new Enhancer(); // 设置enhancer对象的父类 enhancer.setSuperclass(HelloService.class); // 设置enhancer的回调对象 enhancer.setCallback(new MyMethodInterceptor()); // 创建代理对象 HelloService proxy= (HelloService)enhancer.create(); // 通过代理对象调用目标方法 proxy.sayHello(); &#125;&#125; JDK代理要求被代理的类必须实现接口，有很强的局限性。 而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。 总结一下CGLIB在进行代理的时候都进行了哪些工作？ 生成的代理类继承被代理类。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理. 代理类会为委托方法生成两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法. 当执行代理对象的方法时，会首先判断一下是否存在实现了MethodInterceptor接口的CGLIB$CALLBACK_0;，如果存在，则将调用MethodInterceptor中的intercept方法. 在intercept方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录 在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：通过FastClass机制对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用。 Fastclass机制CGLIB采用了FastClass的机制来实现对被拦截方法的调用。 FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class test10 &#123; //这里，tt可以看作目标对象，fc可以看作是代理对象；首先根据代理对象的getIndex方法获取目标方法的索引， //然后再调用代理对象的invoke方法就可以直接调用目标类的方法，避免了反射 public static void main(String[] args)&#123; Test tt = new Test(); Test2 fc = new Test2(); int index = fc.getIndex(&quot;f()V&quot;); fc.invoke(index, tt, null); &#125;&#125;class Test&#123; public void f()&#123; System.out.println(&quot;f method&quot;); &#125; public void g()&#123; System.out.println(&quot;g method&quot;); &#125;&#125;class Test2&#123; public Object invoke(int index, Object o, Object[] ol)&#123; Test t = (Test) o; switch(index)&#123; case 1: t.f(); return null; case 2: t.g(); return null; &#125; return null; &#125; //这个方法对Test类中的方法建立索引 public int getIndex(String signature)&#123; switch(signature.hashCode())&#123; case 3078479: return 1; case 3108270: return 2; &#125; return -1; &#125;&#125; 上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。 在getIndex方法中对Test的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。 Invoke根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率。 思考CGlib比JDK快？使用CGLiB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。 Spring如何选择用JDK还是CGLIB？当Bean实现接口时，Spring就会用JDK的动态代理。当Bean没有实现接口时，Spring使用CGlib实现。可以强制使用CGlib","categories":[{"name":"语言","slug":"语言","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/"},{"name":"设计模式","slug":"语言/设计模式","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://azoker.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"https://azoker.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"一切为了开发","slug":"一切为了开发","permalink":"https://azoker.top/categories/%E4%B8%80%E5%88%87%E4%B8%BA%E4%BA%86%E5%BC%80%E5%8F%91/"},{"name":"Java后端开发","slug":"Java后端开发","permalink":"https://azoker.top/categories/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"代码","slug":"代码","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/"},{"name":"Demo","slug":"代码/Demo","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/Demo/"},{"name":"工具","slug":"工具","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"微信开发者工具","slug":"工具/微信开发者工具","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"},{"name":"语言","slug":"语言","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Vue","slug":"语言/Vue","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/Vue/"},{"name":"Java","slug":"语言/Java","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"IDEA","slug":"工具/IDEA","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/IDEA/"},{"name":"入门案例","slug":"代码/入门案例","permalink":"https://azoker.top/categories/%E4%BB%A3%E7%A0%81/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"},{"name":"Maven","slug":"工具/Maven","permalink":"https://azoker.top/categories/%E5%B7%A5%E5%85%B7/Maven/"},{"name":"框架","slug":"框架","permalink":"https://azoker.top/categories/%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"框架/Mybatis","permalink":"https://azoker.top/categories/%E6%A1%86%E6%9E%B6/Mybatis/"},{"name":"设计模式","slug":"语言/设计模式","permalink":"https://azoker.top/categories/%E8%AF%AD%E8%A8%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://azoker.top/tags/Windows/"},{"name":"Java","slug":"Java","permalink":"https://azoker.top/tags/Java/"},{"name":"oshi","slug":"oshi","permalink":"https://azoker.top/tags/oshi/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://azoker.top/tags/OpenCV/"},{"name":"TomCat","slug":"TomCat","permalink":"https://azoker.top/tags/TomCat/"},{"name":"文件上传","slug":"文件上传","permalink":"https://azoker.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"POI","slug":"POI","permalink":"https://azoker.top/tags/POI/"},{"name":"BUG","slug":"BUG","permalink":"https://azoker.top/tags/BUG/"},{"name":"微信开发者工具","slug":"微信开发者工具","permalink":"https://azoker.top/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"},{"name":"Vue","slug":"Vue","permalink":"https://azoker.top/tags/Vue/"},{"name":"uniapp","slug":"uniapp","permalink":"https://azoker.top/tags/uniapp/"},{"name":"环境配置","slug":"环境配置","permalink":"https://azoker.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"uview","slug":"uview","permalink":"https://azoker.top/tags/uview/"},{"name":"IDEA","slug":"IDEA","permalink":"https://azoker.top/tags/IDEA/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://azoker.top/tags/Mybatis/"},{"name":"Maven","slug":"Maven","permalink":"https://azoker.top/tags/Maven/"},{"name":"设计模式","slug":"设计模式","permalink":"https://azoker.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"https://azoker.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]}